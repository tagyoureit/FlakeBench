{% if is_htmx %}
{% extends "partials/content_only.html" %}
{% else %}
{% extends "base.html" %}
{% endif %}

{% block title %}Template Editor - FlakeBench{% endblock %}

{% block content %}
<div x-data="testConfiguration()">
    <!-- Sticky Template Banner (when editing or viewing a template) -->
    <div x-show="loadedTemplate && !isReadOnly && !hasResults" x-cloak class="floating-toolbar" style="margin-left: 0; margin-right: 0; padding-left: 1rem; padding-right: 1rem;">
        <div class="flex items-center gap-3 flex-1">
            <span class="text-green-600 font-semibold" x-text="config.template_name?.endsWith('(Copy)') ? 'New Template from:' : 'Editing:'"></span>
            <span class="font-medium" x-text="config.template_name?.endsWith('(Copy)') ? config.template_name?.replace(/ \(Copy\)$/, '') : config.template_name"></span>
        </div>
        <div class="flex items-center gap-2">
            <button 
                type="button" 
                class="btn btn-primary btn-sm" 
                :disabled="isTemplateActionInProgress()"
                @click="saveAndPrepare()"
            >
                <span class="loading-spinner" x-show="saveAndPrepareLoading || isSaving"></span>
                <span x-text="(saveAndPrepareLoading || isSaving) ? 'Saving…' : 'Save'"></span>
            </button>
            <a href="/analysis/templates" class="btn btn-secondary btn-sm" hx-get="/analysis/templates" hx-target="#main-content" hx-push-url="true">
                ← Back
            </a>
        </div>
    </div>

    <!-- Sticky Template Banner (when viewing a template with results) -->
    <div x-show="loadedTemplate && isReadOnly" x-cloak class="floating-toolbar" style="margin-left: 0; margin-right: 0; padding-left: 1rem; padding-right: 1rem;">
        <div class="flex items-center gap-3 flex-1">
            <span class="text-blue-600 font-semibold">Viewing Template:</span>
            <span class="font-medium" x-text="loadedTemplate?.template_name"></span>
            <span x-show="hasResults" class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800">
                <span x-text="runsTotal || loadedTemplate?.usage_count || 0"></span> run(s)
            </span>
        </div>
        <div class="flex items-center gap-2">
            <button 
                type="button" 
                class="btn btn-primary btn-sm" 
                :disabled="isTemplateActionInProgress()"
                @click="prepareTemplate()"
            >
                <span class="loading-spinner" x-show="prepareTemplateLoading"></span>
                <span x-text="prepareTemplateLoading ? 'Loading…' : 'Run'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-secondary btn-sm" 
                :disabled="isTemplateActionInProgress() || updateMetadataLoading"
                @click="updateTableMetadata()"
            >
                <span class="loading-spinner" x-show="updateMetadataLoading"></span>
                <span x-text="updateMetadataLoading ? 'Updating…' : 'Update Metadata'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-secondary btn-sm" 
                :disabled="isTemplateActionInProgress()"
                @click="copyTemplate"
            >
                Copy
            </button>
            <a href="/analysis/templates" class="btn btn-secondary btn-sm" hx-get="/analysis/templates" hx-target="#main-content" hx-push-url="true">
                ← Back
            </a>
        </div>
    </div>

    <!-- Initial load state (prevents "defaults then fill in later" flicker) -->
    <div x-show="isInitializing" class="card">
        <div class="flex items-center gap-3">
            <span class="loading-spinner"></span>
            <div>
                <div class="font-semibold">Loading configuration…</div>
                <div class="text-sm text-gray-600">Applying template and fetching warehouses</div>
            </div>
        </div>
    </div>

    <div x-show="!isInitializing" x-cloak>
    <div class="card">
        <div
            class="card-title"
            x-text="isReadOnly ? 'Template Details' : (mode === 'edit' ? 'Edit Template' : 'New Template')"
        ></div>
        <p x-show="!hasResults">Design a test configuration template. Templates can be run multiple times to compare results.</p>

        <div x-show="error" class="alert alert-error mt-4">
            <strong>Unable to load Snowflake data.</strong>
            <span x-text="error"></span>
            <div class="mt-2 text-sm">
                If this looks like a Snowflake connectivity issue, connect to VPN / allowlist your IP and refresh.
            </div>
        </div>
        
        <div x-show="loadedTemplate && !hasResults && !isReadOnly" class="alert alert-success mt-4">
            <strong x-text="loadedTemplate?.template_name?.endsWith('(Copy)') ? 'New Template from:' : 'Editing Template:'"></strong>
            <span x-text="loadedTemplate?.template_name?.endsWith('(Copy)') ? loadedTemplate?.template_name?.replace(/ \(Copy\)$/, '') : loadedTemplate?.template_name"></span>
        </div>
        
        <div x-show="hasResults" class="alert alert-warning mt-4">
            <strong>⚠️ Template has test results</strong><br>
            This template has been used <span x-text="loadedTemplate?.usage_count"></span> time(s) and can no longer be edited. 
            You can <strong>copy</strong> it to create an editable version or <strong>delete</strong> it (which will remove all test results).
        </div>

        <!-- Results warehouse guardrail -->
        <div
            x-show="!hasResults && resultsWarehouse && config.warehouse_name && String(config.warehouse_name).trim().toUpperCase() === resultsWarehouse"
            class="alert alert-warning mt-4"
        >
            <strong>⚠️ Execution warehouse cannot be your results warehouse</strong><br>
            This template is currently set to run on <code x-text="config.warehouse_name"></code>, which matches your results warehouse (<code x-text="resultsWarehouse"></code>).
            Please choose a different warehouse before saving or running.
        </div>
    </div>

    <!-- Template Analytics Section (shown when template has runs) -->
    <div x-show="hasResults && analyticsLoaded" class="mb-6">
        <!-- KPI Cards -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 my-4">
            <!-- QPS Stats -->
            <div class="card text-center">
                <h4 class="text-sm text-gray-500 mb-1">QPS</h4>
                <div class="text-2xl font-bold text-blue-600" x-text="formatNumber(analyticsStats?.qps_stats?.avg, 1)"></div>
                <div class="text-xs text-gray-400">
                    Range: <span x-text="formatNumber(analyticsStats?.qps_stats?.min, 0)"></span> - 
                    <span x-text="formatNumber(analyticsStats?.qps_stats?.max, 0)"></span>
                </div>
                <div class="text-xs text-gray-400" x-show="analyticsStats?.qps_stats?.cv">
                    CV: <span x-text="formatPercent(analyticsStats?.qps_stats?.cv)"></span>
                </div>
            </div>
            
            <!-- P95 Stats -->
            <div class="card text-center">
                <h4 class="text-sm text-gray-500 mb-1">P95 Latency</h4>
                <div class="text-2xl font-bold text-orange-600" x-text="formatLatency(analyticsStats?.p95_stats?.avg)"></div>
                <div class="text-xs text-gray-400">
                    Range: <span x-text="formatLatency(analyticsStats?.p95_stats?.min)"></span> - 
                    <span x-text="formatLatency(analyticsStats?.p95_stats?.max)"></span>
                </div>
            </div>
            
            <!-- Cost Stats -->
            <div class="card text-center">
                <h4 class="text-sm text-gray-500 mb-1">Cost/1K Ops</h4>
                <div class="text-2xl font-bold text-green-600" x-text="analyticsStats?.cost_stats?.cost_per_1k_ops_usd ? ('$' + formatNumber(analyticsStats?.cost_stats?.cost_per_1k_ops_usd, 4)) : 'N/A'"></div>
                <div class="text-xs text-gray-400">
                    Total: $<span x-text="formatNumber(analyticsStats?.cost_stats?.total_cost_usd, 2)"></span>
                </div>
            </div>
            
            <!-- Stability -->
            <div class="card text-center">
                <h4 class="text-sm text-gray-500 mb-1">Stability</h4>
                <div class="text-2xl font-bold" :class="getStabilityTextClass(analyticsStats?.stability?.badge)"
                     x-text="getStabilityLabel(analyticsStats?.stability?.badge)"></div>
                <div class="text-xs text-gray-400" x-show="analyticsStats?.stability?.trend_direction">
                    Trend: <span x-text="analyticsStats?.stability?.trend_direction"></span>
                    (<span x-text="formatPercent(Math.abs(analyticsStats?.stability?.trend_pct || 0) / 100)"></span>)
                </div>
            </div>
        </div>

        <!-- Charts Row -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 my-4">
            <!-- Distribution Histogram -->
            <div class="card">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="card-title card-title--compact">P95 Distribution</h3>
                    <select class="form-select form-select-sm" x-model="distributionMetric" @change="loadDistribution()">
                        <option value="p95_latency_ms">P95 Latency</option>
                        <option value="qps">QPS</option>
                        <option value="p50_latency_ms">P50 Latency</option>
                        <option value="p99_latency_ms">P99 Latency</option>
                    </select>
                </div>
                <div class="relative" style="height: 250px;">
                    <canvas id="distribution-chart"></canvas>
                </div>
            </div>
            
            <!-- Scatter Plot -->
            <div class="card">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="card-title card-title--compact">Performance Scatter</h3>
                    <div class="flex gap-2">
                        <select class="form-select form-select-sm" x-model="scatterX" @change="loadScatter()">
                            <option value="duration_seconds">Duration</option>
                            <option value="total_ops">Total Ops</option>
                            <option value="credits">Credits</option>
                            <option value="qps">QPS</option>
                            <option value="p50">P50</option>
                            <option value="p95">P95</option>
                            <option value="p99">P99</option>
                            <option value="error_rate">Error Rate</option>
                        </select>
                        <span class="text-gray-500">vs</span>
                        <select class="form-select form-select-sm" x-model="scatterY" @change="loadScatter()">
                            <option value="qps">QPS</option>
                            <option value="p50">P50</option>
                            <option value="p95">P95</option>
                            <option value="p99">P99</option>
                            <option value="error_rate">Error Rate</option>
                            <option value="duration_seconds">Duration</option>
                            <option value="total_ops">Total Ops</option>
                            <option value="credits">Credits</option>
                        </select>
                    </div>
                </div>
                <div class="relative" style="height: 250px;">
                    <canvas id="scatter-chart"></canvas>
                </div>
                <div x-show="scatterCorrelation !== null" class="text-center text-sm text-gray-500 mt-2">
                    Correlation: <span x-text="scatterCorrelation?.toFixed(3)"></span>
                </div>
            </div>
        </div>

        <!-- Historical Runs Table -->
        <div class="card my-4">
            <div class="flex items-center justify-between mb-4">
                <h3 class="card-title card-title--compact">Historical Runs</h3>
                <span class="text-sm text-gray-500" x-text="'Total: ' + (runsTotal || 0) + ' runs'"></span>
            </div>
            
            <div class="overflow-x-auto">
                <table class="table table-compact w-full">
                    <thead>
                        <tr>
                            <th class="cursor-pointer" @click="sortRuns('start_time')">
                                Date <span x-show="runsSortBy === 'start_time'" x-text="runsSortOrder === 'desc' ? '↓' : '↑'"></span>
                            </th>
                            <th>Duration</th>
                            <th>Concurrency</th>
                            <th class="cursor-pointer" @click="sortRuns('qps')">
                                QPS <span x-show="runsSortBy === 'qps'" x-text="runsSortOrder === 'desc' ? '↓' : '↑'"></span>
                            </th>
                            <th class="cursor-pointer" @click="sortRuns('p95')">
                                P95 <span x-show="runsSortBy === 'p95'" x-text="runsSortOrder === 'desc' ? '↓' : '↑'"></span>
                            </th>
                            <th>P99</th>
                            <th>Error Rate</th>
                            <th>Cost/1K</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        <template x-for="run in analyticsRuns" :key="run.test_id">
                            <tr :class="run.is_outlier ? 'bg-yellow-50' : ''">
                                <td x-text="formatDateTime(run.start_time)"></td>
                                <td x-text="formatDuration(run.duration_seconds)"></td>
                                <td x-text="run.concurrent_connections || '-'"></td>
                                <td class="font-semibold" x-text="formatNumber(run.qps, 1)"></td>
                                <td x-text="formatLatency(run.p95_ms)"></td>
                                <td x-text="formatLatency(run.p99_ms)"></td>
                                <td :class="run.error_rate > 0.01 ? 'text-red-600' : ''" 
                                    x-text="formatPercent(run.error_rate)"></td>
                                <td x-text="run.cost_per_1k_ops_usd ? ('$' + formatNumber(run.cost_per_1k_ops_usd, 4)) : '-'"></td>
                                <td>
                                    <a :href="'/dashboard/' + run.test_id" 
                                       class="text-blue-600 hover:underline text-sm"
                                       hx-get.attr="'/dashboard/' + run.test_id"
                                       hx-target="#main-content" 
                                       hx-push-url="true">
                                        View
                                    </a>
                                </td>
                            </tr>
                        </template>
                    </tbody>
                </table>
            </div>
            
            <!-- Pagination -->
            <div x-show="runsTotal > runsPageSize" class="flex items-center justify-between mt-4 pt-4 border-t">
                <button class="btn btn-secondary btn-sm" 
                        @click="prevRunsPage()" 
                        :disabled="runsPage <= 1">
                    ← Previous
                </button>
                <span class="text-sm text-gray-500">
                    Page <span x-text="runsPage"></span> of <span x-text="Math.ceil(runsTotal / runsPageSize)"></span>
                </span>
                <button class="btn btn-secondary btn-sm" 
                        @click="nextRunsPage()" 
                        :disabled="runsPage >= Math.ceil(runsTotal / runsPageSize)">
                    Next →
                </button>
            </div>
        </div>
    </div>

    <form @submit.prevent="submitTest" :class="{ 'read-only-form': isReadOnly }">
        <fieldset :disabled="isSaving || aiPrepLoading || saveAndPrepareLoading || isReadOnly">
        <!-- Template Metadata Section (moved to top for better visibility) -->
        <div class="card">
            <div class="card-title">Template Metadata</div>
            
            <div class="form-group">
                <label class="form-label">Template Name *</label>
                <input type="text" class="form-input" x-model="config.template_name" placeholder="e.g., Hybrid Table - 100 Concurrent Mixed Workload" required>
            </div>

            <div class="form-group">
                <label class="form-label">Description</label>
                <textarea class="form-textarea" x-model="config.description" placeholder="Describe what this template tests..."></textarea>
            </div>
        </div>

        <!-- Connection Selection -->
        <div class="card">
            <div class="card-title">Connection</div>
            
            <div class="form-group">
                <label class="form-label">Select Connection *</label>
                <select id="connection-select" class="form-select" x-model="config.connection_id" @change="onConnectionChanged()" required>
                    <option value="">-- Select a connection --</option>
                    <template x-for="conn in availableConnections" :key="conn.connection_id">
                        <option 
                            :value="conn.connection_id" 
                            x-text="conn.connection_name + ' (' + conn.connection_type + ')'"
                        ></option>
                    </template>
                </select>
                <small class="form-text">Choose which database connection to use for this test</small>
            </div>
        </div>

        <div class="card">
            <div class="card-title">Table Configuration</div>
            
            <!-- Object Type Filter - only show for Snowflake connections -->
            <div class="form-group" x-show="!isPostgresConnection()">
                <label class="form-label">Object Type Filter</label>
                <select class="form-select" x-model="objectTypeFilter" @change="onObjectTypeFilterChanged()">
                    <option value="ALL_SNOWFLAKE">All Snowflake</option>
                    <option value="STANDARD">Standard Tables</option>
                    <option value="HYBRID">Hybrid Tables</option>
                    <option value="DYNAMIC">Dynamic Tables</option>
                    <option value="INTERACTIVE">Interactive Tables</option>
                    <option value="VIEW">Views</option>
                </select>
                <small class="form-text">Filter by table type</small>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div class="form-group">
                    <label class="form-label">Database</label>
                    <select id="database-select" class="form-select" x-model="config.database" @change="onDatabaseChanged()" required>
                        <option value="">-- Select a database --</option>
                        <template x-for="db in availableDatabases" :key="db.name">
                            <option :value="String(db.name || '')" x-text="db.name"></option>
                        </template>
                    </select>
                    <small class="form-text">Select an existing database</small>
                </div>

                <div class="form-group">
                    <label class="form-label">Schema</label>
                    <select
                        id="schema-select"
                        class="form-select"
                        x-model="config.schema"
                        @change="onSchemaChanged()"
                        :disabled="!config.database"
                        required
                    >
                        <option value="">-- Select a schema --</option>
                        <template x-for="s in availableSchemas" :key="s.name">
                            <option :value="String(s.name || '')" x-text="s.name"></option>
                        </template>
                    </select>
                    <small class="form-text">Select an existing schema</small>
                </div>

                <div class="form-group">
                    <label class="form-label">Table / View</label>
                    <select id="table-select" class="form-select" x-model="config.table_name" @change="onTableSelected()" :disabled="!config.schema" required>
                        <option value="">-- Select a table or view --</option>
                        <template x-for="obj in availableObjects" :key="obj.detected_type + ':' + obj.name">
                            <option
                                :value="String(obj.name || '')"
                                x-text="objectDisplayName(obj)"
                            ></option>
                        </template>
                    </select>
                    <small class="form-text">Select an existing table or view</small>
                </div>
            </div>

            <div class="alert alert-info mt-3">
                <strong>Full Table Name:</strong> <code x-text="config.database + '.' + config.schema + '.' + config.table_name"></code>
                <span x-show="detectedTableType" class="ml-3">
                    <strong>Detected Type:</strong>
                    <span
                        class="inline-block px-2 py-0.5 text-xs font-semibold rounded"
                        :class="{
                            'bg-blue-100 text-blue-800': detectedTableType === 'STANDARD',
                            'bg-purple-100 text-purple-800': detectedTableType === 'HYBRID',
                            'bg-orange-100 text-orange-800': detectedTableType === 'INTERACTIVE',
                            'bg-green-100 text-green-800': detectedTableType === 'VIEW',
                            'bg-gray-100 text-gray-800': detectedTableType === 'TABLE'
                        }"
                        x-text="detectedTableType"
                    ></span>
                </span>
            </div>
        </div>

        <!-- Interactive Table Info & Warnings -->
        <div x-show="detectedTableType === 'INTERACTIVE' && (interactiveTableClusterBy || interactiveTableWarnings.length > 0)" class="card" style="border-left: 4px solid #f97316;">
            <div class="card-title" style="color: #c2410c;">
                <svg xmlns="http://www.w3.org/2000/svg" class="inline-block w-5 h-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                Interactive Table Configuration
            </div>
            
            <!-- Cluster Key Info -->
            <div x-show="interactiveTableClusterBy" class="mb-3">
                <strong>Cluster Key:</strong>
                <code class="ml-2 px-2 py-1 bg-gray-100 rounded text-sm" x-text="interactiveTableClusterBy ? '(' + interactiveTableClusterBy.join(', ') + ')' : 'N/A'"></code>
                <p class="text-sm text-gray-600 mt-1">
                    Interactive Tables have a 5-second query timeout. Queries must filter on the cluster key columns for optimal performance.
                </p>
            </div>

            <!-- Warnings -->
            <template x-for="(warning, idx) in interactiveTableWarnings" :key="idx">
                <div class="alert alert-warning mb-2" style="background-color: #fef3c7; border: 1px solid #f59e0b; color: #92400e;">
                    <span x-text="warning"></span>
                </div>
            </template>
        </div>

        <div class="card" x-show="config.table_type !== 'POSTGRES'">
            <div class="card-title">Warehouse Configuration</div>
            
            <div class="form-group">
                <label class="form-label">Select Warehouse</label>
                <select
                    id="warehouse-select"
                    class="form-select"
                    x-model="config.warehouse_name"
                    @change="loadWarehouseDetails"
                    :required="config.table_type !== 'POSTGRES'"
                >
                    <option value="">-- Select a warehouse --</option>
                    <template x-for="wh in availableWarehouses" :key="wh.name">
                        <option
                            :value="String(wh.name || '')"
                            x-text="formatWarehouseOption(wh)"
                        ></option>
                    </template>
                </select>
                <small class="form-text">Select existing warehouse - size and settings will be auto-populated</small>
            </div>
            
            <div x-show="config.warehouse_name" class="alert alert-info mt-3">
                <strong>Warehouse Details:</strong><br>
                <span x-show="selectedWarehouseDetails">
                    <strong>Name:</strong> <span x-text="selectedWarehouseDetails?.name || config.warehouse_name"></span><br>
                    <strong>Size:</strong> <span x-text="selectedWarehouseDetails?.size"></span><br>
                    <strong>State:</strong> <span x-text="selectedWarehouseDetails?.state"></span><br>
                    <strong>Type:</strong> <span x-text="selectedWarehouseDetails?.type"></span><br>
                    <strong>Generation:</strong> 
                    <span x-text="selectedWarehouseDetails?.resource_constraint === 'STANDARD_GEN_2' ? 'Gen 2' : 'Gen 1'"></span><br>
                    
                    <!-- Multi-Cluster Warehouse Details -->
                    <span x-show="selectedWarehouseDetails?.max_cluster_count > 1">
                        <hr class="my-2">
                        <strong>Multi-Cluster Configuration:</strong><br>
                        &nbsp;&nbsp;• Min Clusters: <span x-text="selectedWarehouseDetails?.min_cluster_count"></span><br>
                        &nbsp;&nbsp;• Max Clusters: <span x-text="selectedWarehouseDetails?.max_cluster_count"></span><br>
                        &nbsp;&nbsp;• Scaling Policy: <span x-text="selectedWarehouseDetails?.scaling_policy"></span><br>
                        &nbsp;&nbsp;• Currently Started: <span x-text="selectedWarehouseDetails?.started_clusters"></span> cluster(s)<br>
                    </span>
                    
                    <!-- Single Cluster -->
                    <span x-show="selectedWarehouseDetails?.max_cluster_count === 1">
                        <strong>Multi-Cluster:</strong> <span class="text-muted">Not Enabled (Single Cluster)</span><br>
                    </span>
                    
                    <!-- Query Acceleration Service (QAS) -->
                    <hr class="my-2">
                    <strong>Query Acceleration Service (QAS):</strong> 
                    <span x-text="selectedWarehouseDetails?.enable_query_acceleration ? 'Enabled' : 'Disabled'"></span>
                    <span x-show="selectedWarehouseDetails?.enable_query_acceleration">
                        (Max Scale Factor: <span x-text="selectedWarehouseDetails?.query_acceleration_max_scale_factor"></span>)
                    </span><br>
                    
                    <!-- Auto-Suspend/Resume Settings -->
                    <hr class="my-2">
                    <strong>Auto Settings:</strong><br>
                    &nbsp;&nbsp;• Auto-Suspend: <span x-text="selectedWarehouseDetails?.auto_suspend ? selectedWarehouseDetails.auto_suspend + ' seconds' : 'Disabled'"></span><br>
                    &nbsp;&nbsp;• Auto-Resume: <span x-text="selectedWarehouseDetails?.auto_resume ? 'Enabled' : 'Disabled'"></span><br>
                </span>
            </div>
        </div>
        
        <div class="card" x-show="isPostgresFamilyTableType(config.table_type)">
            <div class="card-title">Postgres Connection Settings</div>
            
            <div class="form-group">
                <label class="form-label" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" x-model="config.use_pgbouncer" style="margin: 0;">
                    Use PgBouncer
                </label>
                <small class="form-text">
                    Connects via PgBouncer for connection pooling. Requires <code>snowflake_pooler</code> extension 
                    and a non-superuser role. <strong>Without PgBouncer: max 500 connections. With PgBouncer: up to 1000.</strong>
                </small>
            </div>

            <div class="alert alert-info mt-3">
                Warehouse selection is not used for Postgres-based templates. Results are still recorded to Snowflake using the `.env` `SNOWFLAKE_WAREHOUSE`.
            </div>
        </div>

        <div class="card">
            <div class="card-title flex items-center gap-2">
                Queries, Mix, and Targets
                <button 
                    type="button" 
                    class="text-gray-400 hover:text-blue-600 transition-colors"
                    @click="showQueryHelp = true"
                    title="Learn about SQL parameters and table metadata"
                >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            <p class="text-sm text-gray-700">
                Templates store all SQL and mix weights. Mix presets only adjust weights (SQL is left unchanged).
            </p>

            <div class="form-group">
                <label class="form-label">Mix Preset</label>
                <select class="form-select" x-model="config.mix_preset" @change="applyMixPreset(config.mix_preset)" :disabled="isInteractiveTable(config.table_type)">
                    <option value="READ_ONLY">Read Only (50/50 reads)</option>
                    <option value="WRITE_ONLY" x-bind:disabled="isInteractiveTable(config.table_type)">Write Only (70/30 writes)</option>
                    <option value="READ_HEAVY" x-bind:disabled="isInteractiveTable(config.table_type)">Read Heavy (80/20)</option>
                    <option value="WRITE_HEAVY" x-bind:disabled="isInteractiveTable(config.table_type)">Write Heavy (20/80)</option>
                    <option value="MIXED" x-bind:disabled="isInteractiveTable(config.table_type)">Mixed (50/50)</option>
                    <option value="CUSTOM" x-bind:disabled="isInteractiveTable(config.table_type)">Custom (manual)</option>
                </select>
                <small class="form-text">
                    Presets only change the percentages below. They do <strong>not</strong> change SQL.
                </small>
            </div>

            <div x-show="isInteractiveTable(config.table_type)" class="alert alert-warning mt-3">
                <strong>⚠️ Interactive Table Limitation:</strong> Interactive tables do not support DML operations (INSERT, UPDATE, DELETE). 
                Only read operations (Point Lookup, Range Scan) are available for benchmarking.
                <a href="https://docs.snowflake.com/en/sql-reference/sql/create-interactive-table#usage-notes" target="_blank" rel="noopener">Learn more</a>
            </div>

            <div class="btn-group mt-2">
                <button
                    type="button"
                    class="btn btn-secondary"
                    :disabled="aiSqlAdjustLoading || !hasSelectedTable()"
                    @click="aiAdjustCustomSql()"
                    title="Generates SQL for the selected table only. For multi-table JOINs, edit the SQL manually."
                >
                    <span class="loading-spinner" x-show="aiSqlAdjustLoading"></span>
                    <span x-text="aiSqlAdjustLoading ? 'Generating…' : 'Generate SQL for This Table Type'"></span>
                </button>
            </div>

            <div class="alert alert-info mt-3">
                <div class="text-sm">
                    <div><strong>SQL placeholder:</strong> use <code>{table}</code> for the full table name.</div>
                    <div x-show="isPostgresFamilyTableType(config.table_type)">
                        <strong>Parameters:</strong> Postgres uses <code>$1</code>, <code>$2</code>, …
                    </div>
                    <div x-show="!isPostgresFamilyTableType(config.table_type)">
                        <strong>Parameters:</strong> Snowflake uses <code>?</code>.
                    </div>
                    <div class="mt-1">
                        <strong>Strict evaluation:</strong> a run is compliant only if all enabled per-query targets are met.
                    </div>
                </div>
            </div>

            <div class="alert alert-info mt-3">
                <strong>Total mix must equal 100%.</strong>
                Current total:
                <code x-text="mixTotal().toFixed(2) + '%'"></code>
            </div>

            <div class="overflow-x-auto mt-3">
                <table class="w-full border-collapse" style="table-layout: fixed;">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="p-2 text-left border-b-2 border-gray-200 whitespace-nowrap" style="width: 7rem;">Query Type</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 5rem;">Mix %</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 8rem;">P95 Target (ms)</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 8rem;">P99 Target (ms)</th>
                            <th class="p-2 text-right border-b-2 border-gray-200 whitespace-nowrap" style="width: 7rem;">Max Error %</th>
                            <th class="p-2 text-left border-b-2 border-gray-200">SQL (stored in template)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="p-2 border-b border-gray-200 font-medium">Point Lookup</td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right" style="width: 5rem;" x-model.number="config.custom_point_lookup_pct" @blur="normalizeMixPct('custom_point_lookup_pct')" min="0" max="100" step="0.01">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_point_lookup_p95_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_point_lookup_p99_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_point_lookup_error_rate_pct" min="-1" max="100" step="0.1">
                            </td>
                            <td class="p-2 border-b border-gray-200">
                                <template x-if="editingSql !== 'point_lookup'">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_point_lookup_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('point_lookup')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="editingSql === 'point_lookup'">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_point_lookup_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('point_lookup')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                        <tr>
                            <td class="p-2 border-b border-gray-200 font-medium">Range Scan</td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right" style="width: 5rem;" x-model.number="config.custom_range_scan_pct" @blur="normalizeMixPct('custom_range_scan_pct')" min="0" max="100" step="0.01">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_range_scan_p95_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_range_scan_p99_latency_ms" min="-1">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_range_scan_error_rate_pct" min="-1" max="100" step="0.1">
                            </td>
                            <td class="p-2 border-b border-gray-200">
                                <template x-if="editingSql !== 'range_scan'">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_range_scan_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('range_scan')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="editingSql === 'range_scan'">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_range_scan_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('range_scan')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                        <tr :class="{ 'opacity-50': isInteractiveTable(config.table_type) }">
                            <td class="p-2 border-b border-gray-200 font-medium">
                                Insert
                                <span x-show="isInteractiveTable(config.table_type)" class="text-xs text-red-600 block">(N/A)</span>
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right" style="width: 5rem;" x-model.number="config.custom_insert_pct" @blur="normalizeMixPct('custom_insert_pct')" min="0" max="100" step="0.01" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_insert_p95_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_insert_p99_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right border-b border-gray-200">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_insert_error_rate_pct" min="-1" max="100" step="0.1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 border-b border-gray-200">
                                <template x-if="editingSql !== 'insert' && !isInteractiveTable(config.table_type)">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_insert_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('insert')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="isInteractiveTable(config.table_type)">
                                    <span class="text-xs text-gray-500 italic">Not supported on interactive tables</span>
                                </template>
                                <template x-if="editingSql === 'insert' && !isInteractiveTable(config.table_type)">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_insert_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('insert')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                        <tr :class="{ 'opacity-50': isInteractiveTable(config.table_type) }">
                            <td class="p-2 font-medium">
                                Update
                                <span x-show="isInteractiveTable(config.table_type)" class="text-xs text-red-600 block">(N/A)</span>
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right" style="width: 5rem;" x-model.number="config.custom_update_pct" @blur="normalizeMixPct('custom_update_pct')" min="0" max="100" step="0.01" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_update_p95_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_update_p99_latency_ms" min="-1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2 text-right">
                                <input type="number" class="form-input text-right max-w-40" x-model.number="config.target_update_error_rate_pct" min="-1" max="100" step="0.1" :disabled="isInteractiveTable(config.table_type)">
                            </td>
                            <td class="p-2">
                                <template x-if="editingSql !== 'update' && !isInteractiveTable(config.table_type)">
                                    <div class="flex items-start gap-2">
                                        <pre class="text-xs m-0 whitespace-pre-wrap break-words max-h-16 overflow-y-auto flex-1 bg-slate-50 p-1 px-2 rounded border border-slate-300" x-text="formatSqlDisplay(config.custom_update_query)"></pre>
                                        <button type="button" class="btn btn-secondary btn-sm flex-shrink-0" @click="toggleSqlEdit('update')">Edit</button>
                                    </div>
                                </template>
                                <template x-if="isInteractiveTable(config.table_type)">
                                    <span class="text-xs text-gray-500 italic">Not supported on interactive tables</span>
                                </template>
                                <template x-if="editingSql === 'update' && !isInteractiveTable(config.table_type)">
                                    <div>
                                        <textarea class="form-textarea font-mono text-xs" rows="4" style="min-width: 28rem;" x-model="config.custom_update_query"></textarea>
                                        <button type="button" class="btn btn-primary btn-sm mt-1" @click="toggleSqlEdit('update')">Done</button>
                                    </div>
                                </template>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="mt-4 p-3 border border-gray-200 rounded bg-slate-50">
                <div class="flex items-center justify-between gap-2">
                    <div class="font-medium">Generic SQL Entries (`GENERIC_SQL`)</div>
                    <button type="button" class="btn btn-secondary btn-sm" @click="addGenericQuery()">
                        + Add Generic SQL
                    </button>
                </div>
                <p class="text-xs text-gray-600 mt-1">
                    Add any number of arbitrary SQL entries and mix them with shortcut queries.
                    Each entry requires an operation type and weight.
                </p>

                <template x-if="!Array.isArray(config.generic_queries) || config.generic_queries.length === 0">
                    <div class="text-sm text-gray-500 mt-3 italic">No generic SQL entries configured.</div>
                </template>

                <template x-for="(q, idx) in config.generic_queries" :key="q.id || idx">
                    <div class="mt-3 p-3 border border-gray-200 rounded bg-white">
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-2">
                            <div>
                                <label class="form-label text-xs">Entry ID</label>
                                <input type="text" class="form-input text-sm" x-model="q.id" @input="config.mix_preset = 'CUSTOM'" placeholder="GENERIC_SQL_1">
                            </div>
                            <div>
                                <label class="form-label text-xs">Label (optional)</label>
                                <input type="text" class="form-input text-sm" x-model="q.label" @input="config.mix_preset = 'CUSTOM'" placeholder="monthly_rollup">
                            </div>
                            <div>
                                <label class="form-label text-xs">Operation Type</label>
                                <select class="form-select text-sm" x-model="q.operation_type" @change="config.mix_preset = 'CUSTOM'">
                                    <option value="READ">READ</option>
                                    <option value="WRITE">WRITE</option>
                                </select>
                            </div>
                            <div>
                                <label class="form-label text-xs">Mix %</label>
                                <input type="number" class="form-input text-sm text-right" x-model.number="q.weight_pct" @blur="q.weight_pct = parseFloat((Number(q.weight_pct) || 0).toFixed(2))" @input="config.mix_preset = 'CUSTOM'" min="0" max="100" step="0.01">
                            </div>
                        </div>
                        <div class="mt-2">
                            <label class="form-label text-xs">SQL</label>
                            <textarea class="form-textarea font-mono text-xs" rows="4" x-model="q.sql" @input="config.mix_preset = 'CUSTOM'" placeholder="SELECT ... FROM {table} WHERE ..."></textarea>
                        </div>
                        <div class="mt-2 flex justify-end">
                            <button type="button" class="btn btn-secondary btn-sm" @click="removeGenericQuery(idx)">
                                Remove
                            </button>
                        </div>
                    </div>
                </template>
            </div>

            <small class="form-text mt-2">
                Tip: leave a target at <code>-1</code> to disable it for that query type.
            </small>
        </div>

        <!-- Load & Scaling Card (compact 2-column layout) -->
        <div class="card">
            <div class="card-title">Load & Scaling</div>

            <!-- Mode selectors always at top, side by side -->
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Load Mode</label>
                    <select class="form-select" x-model="config.load_mode">
                        <option value="CONCURRENCY">Fixed threads</option>
                        <option value="QPS">Target throughput (QPS)</option>
                        <option value="FIND_MAX_CONCURRENCY">Find max throughput</option>
                    </select>
                </div>
                <div class="form-group" style="margin-bottom: 0;">
                    <label class="form-label">Scaling Mode</label>
                    <select class="form-select" x-model="config.scaling.mode">
                        <option value="AUTO">Auto</option>
                        <option value="BOUNDED">Bounded</option>
                        <option value="FIXED">Fixed</option>
                    </select>
                </div>
            </div>

            <!-- CONCURRENCY mode options -->
            <div x-show="String(config.load_mode || 'CONCURRENCY').toUpperCase() === 'CONCURRENCY'">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <!-- Left: Load parameters -->
                    <div>
                        <div style="padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 0.75rem; background-color: #eff6ff; border: 1px solid #bfdbfe;">
                            <div style="font-size: 0.875rem; color: #1e40af;">
                                <strong>Fixed Threads</strong> maintains constant concurrency throughout the test.
                                All threads run continuously for the specified duration.
                            </div>
                        </div>
                        <!-- Threads field - hidden when FIXED scaling -->
                        <div class="form-group" x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() !== 'FIXED'">
                            <label class="form-label" for="concurrency-total-threads">Total Threads</label>
                            <input type="number" class="form-input" id="concurrency-total-threads" name="concurrent_connections" data-testid="concurrency-total-threads" x-model.number="config.concurrent_connections" min="1" aria-describedby="concurrency-total-threads-hint">
                            <small id="concurrency-total-threads-hint" class="form-text">Concurrent operations across all workers</small>
                        </div>
                        <!-- Timing -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label class="form-label" for="concurrency-warmup" style="font-size: 0.75rem;">Warmup (s)</label>
                                <input type="number" class="form-input" id="concurrency-warmup" name="warmup" data-testid="concurrency-warmup" x-model.number="config.warmup" min="0" max="300">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="concurrency-duration" style="font-size: 0.75rem;">Duration (s)</label>
                                <input type="number" class="form-input" id="concurrency-duration" name="duration" data-testid="concurrency-duration" x-model.number="config.duration" min="10" max="3600">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="concurrency-think-time" style="font-size: 0.75rem;">Think (ms)</label>
                                <input type="number" class="form-input" id="concurrency-think-time" name="think_time" data-testid="concurrency-think-time" x-model.number="config.think_time" min="0" max="10000">
                            </div>
                        </div>
                    </div>
                    <!-- Right: Scaling parameters -->
                    <div>
                        <!-- AUTO mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'AUTO'" style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #f3f4f6; color: #6b7280; margin-bottom: 0.75rem;">
                            Workers computed automatically from total threads.
                        </div>
                        <!-- FIXED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'FIXED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="concurrency-fixed-workers" style="font-size: 0.75rem;">Workers</label>
                                    <input type="number" class="form-input" id="concurrency-fixed-workers" name="scaling_min_workers" data-testid="concurrency-fixed-workers" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="concurrency-fixed-threads-per-worker" style="font-size: 0.75rem;">Threads/Worker</label>
                                    <input type="number" class="form-input" id="concurrency-fixed-threads-per-worker" name="scaling_min_connections" data-testid="concurrency-fixed-threads-per-worker" x-model.number="config.scaling.min_connections" min="1" max="200" step="1">
                                </div>
                            </div>
                            <div style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #dbeafe; color: #1e40af;">
                                <strong>Total:</strong> 
                                <span x-text="(Number(config.scaling?.min_workers) || 1) + ' × ' + (Number(config.scaling?.min_connections) || 1) + ' = ' + ((Number(config.scaling?.min_workers) || 1) * (Number(config.scaling?.min_connections) || 1)) + ' threads'"></span>
                            </div>
                        </div>
                        <!-- BOUNDED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'BOUNDED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="concurrency-bounded-min-workers" style="font-size: 0.75rem;">Min Workers</label>
                                    <input type="number" class="form-input" id="concurrency-bounded-min-workers" name="scaling_min_workers" data-testid="concurrency-bounded-min-workers" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="concurrency-bounded-max-workers" style="font-size: 0.75rem;">Max Workers</label>
                                    <input type="number" class="form-input" id="concurrency-bounded-max-workers" name="scaling_max_workers" data-testid="concurrency-bounded-max-workers" x-model.number="config.scaling.max_workers" min="1" step="1" placeholder="∞">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="concurrency-bounded-min-threads" style="font-size: 0.75rem;">Min Threads/Wkr</label>
                                    <input type="number" class="form-input" id="concurrency-bounded-min-threads" name="scaling_min_connections" data-testid="concurrency-bounded-min-threads" x-model.number="config.scaling.min_connections" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="concurrency-bounded-max-threads" style="font-size: 0.75rem;">Max Threads/Wkr</label>
                                    <input type="number" class="form-input" id="concurrency-bounded-max-threads" name="scaling_max_connections" data-testid="concurrency-bounded-max-threads" x-model.number="config.scaling.max_connections" min="1" max="200" step="1" placeholder="200">
                                </div>
                            </div>
                        </div>
                        <!-- Resource Guardrails -->
                        <div style="padding: 0.5rem; border-radius: 0.25rem; background-color: #f9fafb; border: 1px solid #e5e7eb;">
                            <label for="concurrency-guardrails-enabled" style="font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 500;">
                                <input type="checkbox" id="concurrency-guardrails-enabled" name="guardrails_enabled" data-testid="concurrency-guardrails-enabled" x-model="config.guardrails.enabled" style="margin: 0;">
                                <span>Resource Guardrails</span>
                            </label>
                            <div x-show="config.guardrails?.enabled !== false" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" for="concurrency-guardrails-cpu" style="font-size: 0.75rem;">CPU %</label>
                                    <input type="number" class="form-input" id="concurrency-guardrails-cpu" name="guardrails_max_cpu_percent" data-testid="concurrency-guardrails-cpu" x-model.number="config.guardrails.max_cpu_percent" min="1" max="100" step="1">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" for="concurrency-guardrails-memory" style="font-size: 0.75rem;">Memory %</label>
                                    <input type="number" class="form-input" id="concurrency-guardrails-memory" name="guardrails_max_memory_percent" data-testid="concurrency-guardrails-memory" x-model.number="config.guardrails.max_memory_percent" min="1" max="100" step="1">
                                </div>
                            </div>
                            <small x-show="config.guardrails?.enabled === false" style="color: #9ca3af; font-size: 0.75rem;">
                                No host resource limits
                            </small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- QPS mode options -->
            <div x-show="String(config.load_mode || 'CONCURRENCY').toUpperCase() === 'QPS'">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <!-- Left: Load parameters -->
                    <div>
                        <div style="padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 0.75rem; background-color: #eff6ff; border: 1px solid #bfdbfe;">
                            <div style="font-size: 0.875rem; color: #1e40af;">
                                <strong>Target Throughput</strong> adjusts threads dynamically to achieve desired QPS.
                                System adds or removes threads to maintain the specified operations per second.
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="qps-target-qps">Target QPS</label>
                            <input type="number" class="form-input" id="qps-target-qps" name="target_qps" data-testid="qps-target-qps" x-model.number="config.target_qps" min="1" max="100000" step="1" aria-describedby="qps-target-qps-hint">
                            <small id="qps-target-qps-hint" class="form-text">Operations per second</small>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label class="form-label" for="qps-starting-threads" style="font-size: 0.75rem;">Starting Threads</label>
                                <input type="number" class="form-input" id="qps-starting-threads" name="starting_threads" data-testid="qps-starting-threads" x-model.number="config.starting_threads" min="0" step="1" placeholder="0" aria-describedby="qps-starting-threads-hint">
                                <small id="qps-starting-threads-hint" class="form-text">Initial threads (0 = ramp from min)</small>
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="qps-max-thread-increase" style="font-size: 0.75rem;">Max Threads/Interval</label>
                                <input type="number" class="form-input" id="qps-max-thread-increase" name="max_thread_increase" data-testid="qps-max-thread-increase" x-model.number="config.max_thread_increase" min="1" max="200" step="1" placeholder="15" aria-describedby="qps-max-thread-increase-hint">
                                <small id="qps-max-thread-increase-hint" class="form-text">Max thread increase (~10s)</small>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div class="form-group">
                                <label class="form-label" for="qps-warmup" style="font-size: 0.75rem;">Warmup (s)</label>
                                <input type="number" class="form-input" id="qps-warmup" name="warmup" data-testid="qps-warmup" x-model.number="config.warmup" min="0" max="300">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="qps-duration" style="font-size: 0.75rem;">Duration (s)</label>
                                <input type="number" class="form-input" id="qps-duration" name="duration" data-testid="qps-duration" x-model.number="config.duration" min="10" max="3600">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="qps-think-time" style="font-size: 0.75rem;">Think (ms)</label>
                                <input type="number" class="form-input" id="qps-think-time" name="think_time" data-testid="qps-think-time" x-model.number="config.think_time" min="0" max="10000">
                            </div>
                        </div>
                    </div>
                    <!-- Right: Scaling parameters (same as CONCURRENCY) -->
                    <div>
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'AUTO'" style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #f3f4f6; color: #6b7280; margin-bottom: 0.75rem;">
                            Workers scale dynamically to meet QPS target.
                        </div>
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'FIXED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="qps-fixed-workers" style="font-size: 0.75rem;">Workers</label>
                                    <input type="number" class="form-input" id="qps-fixed-workers" name="scaling_min_workers" data-testid="qps-fixed-workers" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="qps-fixed-threads-per-worker" style="font-size: 0.75rem;">Threads/Worker</label>
                                    <input type="number" class="form-input" id="qps-fixed-threads-per-worker" name="scaling_min_connections" data-testid="qps-fixed-threads-per-worker" x-model.number="config.scaling.min_connections" min="1" max="200" step="1">
                                </div>
                            </div>
                        </div>
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'BOUNDED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="qps-bounded-min-workers" style="font-size: 0.75rem;">Min Workers</label>
                                    <input type="number" class="form-input" id="qps-bounded-min-workers" name="scaling_min_workers" data-testid="qps-bounded-min-workers" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="qps-bounded-max-workers" style="font-size: 0.75rem;">Max Workers</label>
                                    <input type="number" class="form-input" id="qps-bounded-max-workers" name="scaling_max_workers" data-testid="qps-bounded-max-workers" x-model.number="config.scaling.max_workers" min="1" step="1" placeholder="∞">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="qps-bounded-min-threads" style="font-size: 0.75rem;">Min Threads/Wkr</label>
                                    <input type="number" class="form-input" id="qps-bounded-min-threads" name="scaling_min_connections" data-testid="qps-bounded-min-threads" x-model.number="config.scaling.min_connections" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="qps-bounded-max-threads" style="font-size: 0.75rem;">Max Threads/Wkr</label>
                                    <input type="number" class="form-input" id="qps-bounded-max-threads" name="scaling_max_connections" data-testid="qps-bounded-max-threads" x-model.number="config.scaling.max_connections" min="1" max="200" step="1" placeholder="200">
                                </div>
                            </div>
                        </div>
                        <div style="padding: 0.5rem; border-radius: 0.25rem; background-color: #f9fafb; border: 1px solid #e5e7eb;">
                            <label for="qps-guardrails-enabled" style="font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 500;">
                                <input type="checkbox" id="qps-guardrails-enabled" name="guardrails_enabled" data-testid="qps-guardrails-enabled" x-model="config.guardrails.enabled" style="margin: 0;">
                                <span>Resource Guardrails</span>
                            </label>
                            <div x-show="config.guardrails?.enabled !== false" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" for="qps-guardrails-cpu" style="font-size: 0.75rem;">CPU %</label>
                                    <input type="number" class="form-input" id="qps-guardrails-cpu" name="guardrails_max_cpu_percent" data-testid="qps-guardrails-cpu" x-model.number="config.guardrails.max_cpu_percent" min="1" max="100" step="1">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" for="qps-guardrails-memory" style="font-size: 0.75rem;">Memory %</label>
                                    <input type="number" class="form-input" id="qps-guardrails-memory" name="guardrails_max_memory_percent" data-testid="qps-guardrails-memory" x-model.number="config.guardrails.max_memory_percent" min="1" max="100" step="1">
                                </div>
                            </div>
                            <small x-show="config.guardrails?.enabled === false" style="color: #9ca3af; font-size: 0.75rem;">
                                No host resource limits
                            </small>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FIND_MAX_CONCURRENCY mode options -->
            <div x-show="String(config.load_mode || 'CONCURRENCY').toUpperCase() === 'FIND_MAX_CONCURRENCY'">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <!-- Left: Find Max parameters -->
                    <div>
                        <div style="padding: 0.75rem; border-radius: 0.25rem; margin-bottom: 0.75rem; background-color: #eff6ff; border: 1px solid #bfdbfe;">
                            <div style="font-size: 0.875rem; color: #1e40af;">
                                <strong>Find Max Throughput</strong> runs until degradation or max threads reached.
                                Starts at initial threads, increments each step until QPS drops, latency spikes, or errors increase.
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
                            <div class="form-group">
                                <label class="form-label" for="findmax-start-threads" style="font-size: 0.75rem;">Start Threads</label>
                                <input type="number" class="form-input" id="findmax-start-threads" name="start_concurrency" data-testid="findmax-start-threads" x-model.number="config.start_concurrency" min="1" max="100" step="1">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="findmax-increment" style="font-size: 0.75rem;">Increment</label>
                                <input type="number" class="form-input" id="findmax-increment" name="concurrency_increment" data-testid="findmax-increment" x-model.number="config.concurrency_increment" min="1" max="100" step="1">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="findmax-step-duration" style="font-size: 0.75rem;">Step Duration (s)</label>
                                <input type="number" class="form-input" id="findmax-step-duration" name="step_duration_seconds" data-testid="findmax-step-duration" x-model.number="config.step_duration_seconds" min="10" max="300" step="5">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="findmax-warmup" style="font-size: 0.75rem;">Warmup (s)</label>
                                <input type="number" class="form-input" id="findmax-warmup" name="warmup" data-testid="findmax-warmup" x-model.number="config.warmup" min="0" max="300">
                            </div>
                        </div>

                        <details style="margin-bottom: 0.75rem;">
                            <summary style="font-size: 0.875rem; font-weight: 600; cursor: pointer; color: #6b7280;">
                                Advanced: stability thresholds
                            </summary>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; margin-top: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="findmax-qps-stability" style="font-size: 0.75rem;">QPS Drop %</label>
                                    <input type="number" class="form-input" id="findmax-qps-stability" name="qps_stability_pct" data-testid="findmax-qps-stability" x-model.number="config.qps_stability_pct" min="1" max="50" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="findmax-latency-stability" style="font-size: 0.75rem;">P95 Latency %</label>
                                    <input type="number" class="form-input" id="findmax-latency-stability" name="latency_stability_pct" data-testid="findmax-latency-stability" x-model.number="config.latency_stability_pct" min="5" max="100" step="5">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="findmax-max-error-rate" style="font-size: 0.75rem;">Max Error %</label>
                                    <input type="number" class="form-input" id="findmax-max-error-rate" name="max_error_rate_pct" data-testid="findmax-max-error-rate" x-model.number="config.max_error_rate_pct" min="0" max="100" step="0.5">
                                </div>
                            </div>
                        </details>

                        <div style="padding: 0.5rem; border-radius: 0.25rem; background-color: #f9fafb; border: 1px solid #e5e7eb; max-width: 350px;">
                            <label for="findmax-guardrails-enabled" style="font-size: 0.75rem; display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem; font-weight: 500;">
                                <input type="checkbox" id="findmax-guardrails-enabled" name="guardrails_enabled" data-testid="findmax-guardrails-enabled" x-model="config.guardrails.enabled" style="margin: 0;">
                                <span>Resource Guardrails</span>
                            </label>
                            <div x-show="config.guardrails?.enabled !== false" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" for="findmax-guardrails-cpu" style="font-size: 0.75rem;">CPU %</label>
                                    <input type="number" class="form-input" id="findmax-guardrails-cpu" name="guardrails_max_cpu_percent" data-testid="findmax-guardrails-cpu" x-model.number="config.guardrails.max_cpu_percent" min="1" max="100" step="1">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" for="findmax-guardrails-memory" style="font-size: 0.75rem;">Memory %</label>
                                    <input type="number" class="form-input" id="findmax-guardrails-memory" name="guardrails_max_memory_percent" data-testid="findmax-guardrails-memory" x-model.number="config.guardrails.max_memory_percent" min="1" max="100" step="1">
                                </div>
                            </div>
                            <small x-show="config.guardrails?.enabled === false" style="color: #9ca3af; font-size: 0.75rem;">
                                No host resource limits
                            </small>
                        </div>
                    </div>

                    <!-- Right: Scaling parameters -->
                    <div>
                        <!-- AUTO mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'AUTO'" style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #f3f4f6; color: #6b7280; margin-bottom: 0.75rem;">
                            Workers computed automatically as threads increase.
                        </div>
                        <!-- FIXED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'FIXED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="findmax-fixed-workers" style="font-size: 0.75rem;">Workers</label>
                                    <input type="number" class="form-input" id="findmax-fixed-workers" name="scaling_min_workers" data-testid="findmax-fixed-workers" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="findmax-fixed-threads-per-worker" style="font-size: 0.75rem;">Threads/Worker</label>
                                    <input type="number" class="form-input" id="findmax-fixed-threads-per-worker" name="scaling_min_connections" data-testid="findmax-fixed-threads-per-worker" x-model.number="config.scaling.min_connections" min="1" max="200" step="1">
                                </div>
                            </div>
                            <div style="padding: 0.5rem; border-radius: 0.25rem; font-size: 0.875rem; background-color: #dbeafe; color: #1e40af;">
                                Find Max will increment threads within fixed worker count
                            </div>
                        </div>
                        <!-- BOUNDED mode -->
                        <div x-show="String(config.scaling?.mode || 'AUTO').toUpperCase() === 'BOUNDED'" style="margin-bottom: 0.75rem;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                                <div class="form-group">
                                    <label class="form-label" for="findmax-bounded-min-workers" style="font-size: 0.75rem;">Min Workers</label>
                                    <input type="number" class="form-input" id="findmax-bounded-min-workers" name="scaling_min_workers" data-testid="findmax-bounded-min-workers" x-model.number="config.scaling.min_workers" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="findmax-bounded-max-workers" style="font-size: 0.75rem;">Max Workers</label>
                                    <input type="number" class="form-input" id="findmax-bounded-max-workers" name="scaling_max_workers" data-testid="findmax-bounded-max-workers" x-model.number="config.scaling.max_workers" min="1" step="1" placeholder="∞">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="findmax-bounded-min-threads" style="font-size: 0.75rem;">Min Threads/Wkr</label>
                                    <input type="number" class="form-input" id="findmax-bounded-min-threads" name="scaling_min_connections" data-testid="findmax-bounded-min-threads" x-model.number="config.scaling.min_connections" min="1" step="1">
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="findmax-bounded-max-threads" style="font-size: 0.75rem;">Max Threads/Wkr</label>
                                    <input type="number" class="form-input" id="findmax-bounded-max-threads" name="scaling_max_connections" data-testid="findmax-bounded-max-threads" x-model.number="config.scaling.max_connections" min="1" max="200" step="1" placeholder="200">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Execution Options (compact inline checkbox) -->
        <div class="card" x-show="config.table_type === 'STANDARD' || config.table_type === 'INTERACTIVE'" style="padding: 0.75rem 1rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem; margin: 0; cursor: pointer;">
                <input type="checkbox" x-model="config.use_cached_result" style="margin: 0;">
                <span style="font-size: 0.875rem;">Use Snowflake result cache (<code style="font-size: 0.8em;">USE_CACHED_RESULT</code>)</span>
            </label>
        </div>

        <!-- Stale Value Pools Warning -->
        <div class="alert alert-warning" x-show="mode === 'edit' && arePoolsStale()" style="margin-bottom: 1rem; display: flex; align-items: flex-start; gap: 0.75rem;">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path>
                <line x1="12" y1="9" x2="12" y2="13"></line>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            <div>
                <strong>Value pools may be outdated.</strong>
                <span x-text="'Pools were created for ' + getPoolSourceTable() + ' but the template now targets a different table.'"></span>
                Click <strong x-text="mode === 'edit' ? 'Update & Populate' : 'Save & Populate'"></strong> to regenerate them.
            </div>
        </div>

        <div class="btn-group" x-show="!isReadOnly">
            <button
                type="button"
                class="btn btn-primary"
                :disabled="isSaving || aiPrepLoading || saveAndPrepareLoading"
                @click="saveAndPrepare()"
                title="Saves template and refreshes table metadata for realistic benchmark parameters"
            >
                <span class="loading-spinner" x-show="saveAndPrepareLoading || isSaving"></span>
                <span x-text="(saveAndPrepareLoading || isSaving) 
                    ? (mode === 'edit' ? 'Updating…' : 'Saving…') 
                    : (mode === 'edit' ? 'Update' : 'Save')"></span>
            </button>
            <button
                type="button"
                class="btn btn-primary"
                x-show="loadedTemplate"
                :disabled="isTemplateActionInProgress()"
                @click="prepareTemplate()"
            >
                <span class="loading-spinner" x-show="prepareTemplateLoading"></span>
                <span x-text="prepareTemplateLoading ? 'Loading…' : 'Run'"></span>
            </button>
            <button type="button" class="btn btn-secondary" :disabled="isTemplateActionInProgress()" @click="cancel" x-text="loadedTemplate ? 'Close' : 'Cancel'"></button>
        </div>
        </fieldset>
    </form>

    <!-- Table Metadata Status (shown in view mode) -->
    <div x-show="isReadOnly && loadedTemplate" class="card">
        <div class="card-title">Table Metadata</div>
        
        <div x-show="!config.ai_workload || !config.ai_workload.pool_id" class="alert alert-warning">
            <div class="flex items-center justify-between">
                <div>
                    <strong>Not initialized.</strong> Table metadata has not been collected for this template.
                    Click "Update Table Metadata" to sample key values from the table for realistic benchmark parameters.
                </div>
                <button 
                    type="button" 
                    class="btn btn-sm btn-primary ml-4"
                    :disabled="updateMetadataLoading"
                    @click="updateTableMetadata()"
                >
                    <span class="loading-spinner" x-show="updateMetadataLoading"></span>
                    <span x-text="updateMetadataLoading ? 'Updating…' : 'Update Table Metadata'"></span>
                </button>
            </div>
        </div>

        <div x-show="aiPrepError && isReadOnly" class="alert alert-error mt-3">
            <strong>Metadata update failed.</strong>
            <span x-text="aiPrepError"></span>
        </div>

        <div x-show="config.ai_workload && config.ai_workload.pool_id" class="alert alert-success">
            <div class="text-sm">
                <div class="flex items-center justify-between">
                    <div>
                        <strong>Initialized:</strong> Yes
                        <span x-show="config.ai_workload?.prepared_at">
                            • <strong>At:</strong> <code x-text="config.ai_workload?.prepared_at || ''"></code>
                        </span>
                    </div>
                    <button 
                        type="button" 
                        class="btn btn-sm btn-secondary"
                        :disabled="updateMetadataLoading"
                        @click="updateTableMetadata()"
                    >
                        <span class="loading-spinner" x-show="updateMetadataLoading"></span>
                        <span x-text="updateMetadataLoading ? 'Updating…' : 'Refresh Metadata'"></span>
                    </button>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.pool_id">
                    <strong>Pool ID:</strong> <code x-text="config.ai_workload?.pool_id || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.key_column">
                    <strong>Key column:</strong> <code x-text="config.ai_workload?.key_column || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.time_column">
                    <strong>Time column:</strong> <code x-text="config.ai_workload?.time_column || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.range_mode">
                    <strong>Range mode:</strong> <code x-text="config.ai_workload?.range_mode || ''"></code>
                </div>
                <div class="mt-1" x-show="config.ai_workload?.domain_label">
                    <strong>Domain:</strong> <code x-text="config.ai_workload?.domain_label || ''"></code>
                </div>
                <div class="mt-2" x-show="config.ai_workload?.pools && Object.keys(config.ai_workload?.pools || {}).length > 0">
                    <strong>Value Pools:</strong>
                    <div class="mt-1 space-y-1">
                        <template x-for="[colName, info] in Object.entries(config.ai_workload?.pools || {})" :key="colName">
                            <div class="flex items-center gap-2 text-sm">
                                <code class="bg-gray-100 px-1 rounded" x-text="colName"></code>
                                <span class="text-gray-500">·</span>
                                <span x-text="(info?.count || 0).toLocaleString() + ' values'"></span>
                                <span class="text-gray-400 text-xs" x-show="info?.kind">(<span x-text="info?.kind"></span>)</span>
                                <span class="text-gray-400 text-xs" x-show="info?.refreshed_at" x-text="'Updated ' + new Date(info?.refreshed_at).toLocaleDateString()"></span>
                            </div>
                        </template>
                    </div>
                </div>
                <div class="mt-2" x-show="config.ai_workload?.ai_notes">
                    <strong>AI Notes:</strong>
                    <div class="text-xs text-gray-600 mt-1" x-text="config.ai_workload?.ai_notes || ''"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Actions when template has results -->
    <div x-show="hasResults || isReadOnly" class="card">
        <div class="btn-group">
            <button 
                type="button" 
                class="btn btn-primary" 
                :disabled="isTemplateActionInProgress()"
                @click="prepareTemplate()"
            >
                <span class="loading-spinner" x-show="prepareTemplateLoading"></span>
                <span x-text="prepareTemplateLoading ? 'Loading…' : 'Run'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-secondary" 
                :disabled="isTemplateActionInProgress() || updateMetadataLoading"
                @click="updateTableMetadata()"
            >
                <span class="loading-spinner" x-show="updateMetadataLoading"></span>
                <span x-text="updateMetadataLoading ? 'Updating…' : 'Update Table Metadata'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-secondary" 
                :disabled="isTemplateActionInProgress()"
                @click="copyTemplate"
            >
                <span class="loading-spinner" x-show="copyTemplateLoading"></span>
                <span x-text="copyTemplateLoading ? 'Copying…' : 'Copy Template'"></span>
            </button>
            <button 
                type="button" 
                class="btn btn-danger" 
                :disabled="isTemplateActionInProgress()"
                @click="deleteTemplateWithResults"
            >
                <span class="loading-spinner" x-show="deleteTemplateLoading"></span>
                <span x-text="deleteTemplateLoading ? 'Deleting…' : 'Delete Template & Results'"></span>
            </button>
            <button type="button" class="btn btn-secondary" :disabled="isTemplateActionInProgress()" @click="cancel">
                Close
            </button>
        </div>
    </div>
</div>

    <!-- Query Help Modal -->
    <div 
        x-show="showQueryHelp" 
        x-cloak
        class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50"
        @click.self="showQueryHelp = false"
        @keydown.escape.window="showQueryHelp = false"
    >
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-2xl mx-4 max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold">SQL Parameters & Table Metadata</h3>
                <button 
                    type="button" 
                    class="text-gray-500 hover:text-gray-700 text-2xl"
                    @click="showQueryHelp = false"
                >&times;</button>
            </div>
            
            <div class="space-y-4 text-sm">
                <div>
                    <h4 class="font-semibold text-gray-900 mb-1">Parameter Placeholders</h4>
                    <p class="text-gray-700">
                        Use <code class="bg-gray-100 px-1 rounded">?</code> (Snowflake) or 
                        <code class="bg-gray-100 px-1 rounded">$1, $2</code> (Postgres) as parameter placeholders.
                        These are replaced at runtime with sampled values from your table.
                    </p>
                </div>

                <div>
                    <h4 class="font-semibold text-gray-900 mb-1">The {table} Placeholder</h4>
                    <p class="text-gray-700">
                        Use <code class="bg-gray-100 px-1 rounded">{table}</code> to reference your selected table.
                        It expands to <code class="bg-gray-100 px-1 rounded">DATABASE.SCHEMA.TABLE_NAME</code> at runtime.
                    </p>
                </div>

                <div>
                    <h4 class="font-semibold text-gray-900 mb-1">Table Metadata</h4>
                    <p class="text-gray-700">
                        When you click <strong>"Update Table Metadata"</strong>, the system samples real values from your table's 
                        key column (auto-detected) and stores them for the benchmark. During execution, 
                        the <code class="bg-gray-100 px-1 rounded">?</code> parameters are bound from these sampled values, ensuring 
                        queries hit actual rows in your table.
                    </p>
                </div>

                <div class="bg-blue-50 border border-blue-200 rounded p-3">
                    <h4 class="font-semibold text-blue-900 mb-1">Single-Table Design</h4>
                    <p class="text-blue-800">
                        <strong>"Generate SQL"</strong> creates queries for the selected table only. For multi-table JOINs, 
                        edit the SQL manually and hardcode the second table name. The <code class="bg-blue-100 px-1 rounded">?</code> 
                        parameter will still bind from the primary table's key column.
                    </p>
                    <p class="text-blue-800 mt-2">
                        <strong>Example JOIN:</strong>
                    </p>
                    <pre class="bg-blue-100 p-2 rounded text-xs mt-1 overflow-x-auto">SELECT o.*, c.C_NAME 
FROM {table} o
JOIN OTHER_DB.SCHEMA.CUSTOMER c ON o.CUST_ID = c.C_ID
WHERE o.ORDER_KEY = ?</pre>
                </div>

                <div>
                    <h4 class="font-semibold text-gray-900 mb-1">Query Types</h4>
                    <ul class="list-disc list-inside text-gray-700 space-y-1">
                        <li><strong>Point Lookup:</strong> Single-row fetch by key (uses sampled key values)</li>
                        <li><strong>Range Scan:</strong> Multi-row fetch by range (uses sampled key or time values)</li>
                        <li><strong>Insert:</strong> New row with generated values</li>
                        <li><strong>Update:</strong> Modify existing row by key</li>
                    </ul>
                </div>
            </div>

            <div class="mt-6 flex justify-end">
                <button 
                    type="button" 
                    class="btn btn-primary"
                    @click="showQueryHelp = false"
                >Got it</button>
            </div>
        </div>
    </div>
    </div>
{% endblock %}

{% block extra_scripts %}
<script>
function testConfiguration() {
    return {
        config: {
            connection_id: '',  // Selected connection UUID
            table_type: 'STANDARD',
            database: '{{ default_database }}',
            schema: 'PUBLIC',
            table_name: '',
            warehouse_name: '',
            warehouse_size: 'MEDIUM',
            multi_cluster: false,
            min_clusters: 1,
            max_clusters: 3,
            scaling_policy: 'STANDARD',
            duration: 300,
            load_mode: 'CONCURRENCY',
            target_qps: 100,
            starting_threads: null,
            max_thread_increase: 15,
            scaling: {
                mode: 'AUTO',
                min_workers: 1,
                max_workers: null,
                min_connections: 5,
                max_connections: null,
            },
            guardrails: {
                enabled: false,
                max_cpu_percent: 80,
                max_memory_percent: 85,
            },
            concurrent_connections: 10,
            // FIND_MAX_CONCURRENCY mode defaults
            start_concurrency: 5,
            concurrency_increment: 10,
            step_duration_seconds: 30,
            qps_stability_pct: 40.0,
            latency_stability_pct: 100.0,
            max_error_rate_pct: 1.0,
            // Canonical storage model: templates persist CUSTOM SQL + weights.
            // "Mix preset" is a UI helper that only adjusts weights.
            workload_type: 'CUSTOM',
            mix_preset: 'MIXED',
            think_time: 0,
            warmup: 30,
            use_cached_result: true,
            use_pgbouncer: false,  // PgBouncer may not be available on all instances
            custom_point_lookup_query: 'Use AI Adjust or enter sql manually.',
            custom_range_scan_query: 'Use AI Adjust or enter sql manually.',
            custom_insert_query: 'Use AI Adjust or enter sql manually.',
            custom_update_query: 'Use AI Adjust or enter sql manually.',
            custom_point_lookup_pct: 25,
            custom_range_scan_pct: 25,
            custom_insert_pct: 35,
            custom_update_pct: 15,
            generic_queries: [],
            // Per-query-type targets (SLOs). Use -1 to disable a target.
            target_point_lookup_p95_latency_ms: -1,
            target_range_scan_p95_latency_ms: -1,
            target_insert_p95_latency_ms: -1,
            target_update_p95_latency_ms: -1,
            target_point_lookup_p99_latency_ms: -1,
            target_range_scan_p99_latency_ms: -1,
            target_insert_p99_latency_ms: -1,
            target_update_p99_latency_ms: -1,
            target_point_lookup_error_rate_pct: -1,
            target_range_scan_error_rate_pct: -1,
            target_insert_error_rate_pct: -1,
            target_update_error_rate_pct: -1,
            template_name: '',
            description: ''
        },
        loadedTemplate: null,
        availableConnections: [],  // List of available database connections
        availableWarehouses: [],
        selectedWarehouseDetails: null,
        resultsWarehouse: null,
        availableDatabases: [],
        availableSchemas: [],
        availableObjects: [],
        objectTypeFilter: 'ALL_SNOWFLAKE',
        detectedTableType: null,
        interactiveTableClusterBy: null, // Cluster key columns for Interactive Tables
        interactiveTableWarnings: [], // Validation warnings for Interactive Tables
        mode: 'new', // 'new', 'edit', or 'view'
        hasResults: false, // true if template has been used
        isReadOnly: false,
        isInitializing: true,
        isSaving: false,
        error: null,
        aiPrepLoading: false,
        aiPrepError: null,
        aiPrepResult: null,
        aiPrepStatusFromConfig(msg = 'Loaded from template') {
            const w = this.config && this.config.ai_workload ? this.config.ai_workload : null;
            if (!w || typeof w !== 'object') return null;
            const prepared = Boolean(w.pool_id);
            const cortexAvailable = Boolean(
                (w.ai_available != null ? w.ai_available : w.available) || false,
            );
            const cortexError =
                (w.ai_error != null ? w.ai_error : w.availability_error) || null;
            return {
                message: msg,
                prepared,
                prepared_at: w.prepared_at || null,
                pool_id: w.pool_id || null,
                key_column: w.key_column || null,
                time_column: w.time_column || null,
                range_mode: w.range_mode || null,
                pools: w.pools || null,
                cortex_available: cortexAvailable,
                cortex_error: cortexError,
            };
        },
        aiSqlAdjustLoading: false,
        saveAndPrepareLoading: false,
        updateMetadataLoading: false,
        prepareTemplateLoading: false,
        copyTemplateLoading: false,
        deleteTemplateLoading: false,
        
        // Analytics state (for templates with runs)
        analyticsLoaded: false,
        analyticsStats: null,
        analyticsRuns: [],
        runsTotal: 0,
        runsPage: 1,
        runsPageSize: 20,
        runsSortBy: 'start_time',
        runsSortOrder: 'desc',
        distributionMetric: 'p95_latency_ms',
        distributionChart: null,
        scatterX: 'duration_seconds',
        scatterY: 'qps',
        scatterChart: null,
        scatterCorrelation: null,
        
        savedConfigSnapshot: null,

        isDirty() {
            if (!this.savedConfigSnapshot) return false;
            return JSON.stringify(this.getComparableConfig()) !== JSON.stringify(this.savedConfigSnapshot);
        },

        getComparableConfig() {
            const c = this.config;
            return {
                connection_id: c.connection_id,
                template_name: c.template_name,
                description: c.description,
                table_type: c.table_type,
                database: c.database,
                schema: c.schema,
                table_name: c.table_name,
                warehouse_name: c.warehouse_name,
                duration: c.duration,
                warmup: c.warmup,
                think_time: c.think_time,
                load_mode: c.load_mode,
                target_qps: c.target_qps,
                starting_threads: c.starting_threads,
                max_thread_increase: c.max_thread_increase,
                concurrent_connections: c.concurrent_connections,
                start_concurrency: c.start_concurrency,
                concurrency_increment: c.concurrency_increment,
                step_duration_seconds: c.step_duration_seconds,
                mix_preset: c.mix_preset,
                custom_point_lookup_pct: c.custom_point_lookup_pct,
                custom_range_scan_pct: c.custom_range_scan_pct,
                custom_insert_pct: c.custom_insert_pct,
                custom_update_pct: c.custom_update_pct,
                custom_point_lookup_query: c.custom_point_lookup_query,
                custom_range_scan_query: c.custom_range_scan_query,
                custom_insert_query: c.custom_insert_query,
                custom_update_query: c.custom_update_query,
                generic_queries: JSON.stringify(c.generic_queries || []),
                use_cached_result: c.use_cached_result,
                use_pgbouncer: c.use_pgbouncer,
                scaling: JSON.stringify(c.scaling || {}),
                guardrails: JSON.stringify(c.guardrails || {}),
            };
        },

        snapshotConfig() {
            this.savedConfigSnapshot = this.getComparableConfig();
        },

        // Check if any template action is in progress
        isTemplateActionInProgress() {
            return (
                this.prepareTemplateLoading ||
                this.copyTemplateLoading ||
                this.deleteTemplateLoading
            );
        },

        hasSelectedTable() {
            const db = String(this.config.database || '').trim();
            const sch = String(this.config.schema || '').trim();
            const tbl = String(this.config.table_name || '').trim();
            return Boolean(db && sch && tbl);
        },

        // Check if value pools exist for this template
        hasExistingPools() {
            return Boolean(this.config.ai_workload?.pool_id);
        },

        // Check if value pools are stale (created for a different table)
        arePoolsStale() {
            const aw = this.config.ai_workload;
            if (!aw?.pool_id) return false; // No pools = not stale
            // Compare current selection vs what pools were created for
            const currentDb = String(this.config.database || '').trim().toUpperCase();
            const currentSchema = String(this.config.schema || '').trim().toUpperCase();
            const currentTable = String(this.config.table_name || '').trim().toUpperCase();
            const sourceDb = String(aw.source_database || '').trim().toUpperCase();
            const sourceSchema = String(aw.source_schema || '').trim().toUpperCase();
            const sourceTable = String(aw.source_table || '').trim().toUpperCase();
            // If source fields are missing (legacy templates), can't determine staleness
            if (!sourceDb || !sourceSchema || !sourceTable) return false;
            return currentDb !== sourceDb || currentSchema !== sourceSchema || currentTable !== sourceTable;
        },

        // Get the original table name that pools were created for (for warning message)
        getPoolSourceTable() {
            const aw = this.config.ai_workload;
            if (!aw?.source_database) return null;
            return `${aw.source_database}.${aw.source_schema}.${aw.source_table}`;
        },

        // Check if the selected connection is a Postgres connection
        isPostgresConnection() {
            if (!this.config.connection_id) return false;
            const conn = (this.availableConnections || []).find(
                c => c.connection_id === this.config.connection_id
            );
            return conn?.connection_type === 'POSTGRES';
        },

        // Get the selected connection object
        getSelectedConnection() {
            if (!this.config.connection_id) return null;
            return (this.availableConnections || []).find(
                c => c.connection_id === this.config.connection_id
            ) || null;
        },

        isPostgresFamilyTableType(tableType) {
            const tt = String(tableType || '').trim().toUpperCase();
            return tt === 'POSTGRES';
        },

        isInteractiveTable(tableType) {
            const tt = String(tableType || '').trim().toUpperCase();
            return tt === 'INTERACTIVE';
        },

        mixTotal() {
            const shortcutTotal = (
                Number(this.config.custom_point_lookup_pct || 0) +
                Number(this.config.custom_range_scan_pct || 0) +
                Number(this.config.custom_insert_pct || 0) +
                Number(this.config.custom_update_pct || 0)
            );
            const genericQueries = Array.isArray(this.config.generic_queries)
                ? this.config.generic_queries
                : [];
            const genericTotal = genericQueries.reduce((acc, q) => {
                return acc + Number((q && q.weight_pct) || 0);
            }, 0);
            return Math.round((shortcutTotal + genericTotal) * 100) / 100;
        },

        editingSql: null, // tracks which SQL field is being edited: 'point_lookup', 'range_scan', 'insert', 'update', or null
        showQueryHelp: false, // controls visibility of query help modal

        toggleSqlEdit(field) {
            this.editingSql = this.editingSql === field ? null : field;
        },

        formatSqlDisplay(sql) {
            const s = String(sql || '').trim();
            if (!s) return '(empty)';
            return s;
        },

        makeDefaultGenericQuery(index = null) {
            const suffix = index != null ? Number(index) + 1 : Date.now();
            return {
                id: `GENERIC_SQL_${suffix}`,
                query_kind: 'GENERIC_SQL',
                operation_type: 'READ',
                label: '',
                weight_pct: 0,
                sql: '',
                parameters: [],
            };
        },

        normalizeGenericQuery(raw, idx) {
            const row = raw && typeof raw === 'object' ? { ...raw } : {};
            const idRaw = String(row.id || `GENERIC_SQL_${Number(idx) + 1}`).trim();
            const opRaw = String(row.operation_type || '').trim().toUpperCase();
            const op = opRaw === 'WRITE' ? 'WRITE' : 'READ';
            let weight = Number(row.weight_pct || 0);
            if (!Number.isFinite(weight)) weight = 0;
            weight = Math.round(Math.max(0, Math.min(100, weight)) * 100) / 100;
            return {
                ...row,
                id: idRaw || `GENERIC_SQL_${Number(idx) + 1}`,
                query_kind: 'GENERIC_SQL',
                operation_type: op,
                label: String(row.label || '').trim(),
                weight_pct: weight,
                sql: String(row.sql || row.query || row.query_text || '').trim(),
                parameters: Array.isArray(row.parameters) ? row.parameters : [],
            };
        },

        normalizeGenericQueries() {
            if (!Array.isArray(this.config.generic_queries)) {
                this.config.generic_queries = [];
                return;
            }
            this.config.generic_queries = this.config.generic_queries.map((q, idx) =>
                this.normalizeGenericQuery(q, idx),
            );
        },

        addGenericQuery() {
            this.normalizeGenericQueries();
            this.config.generic_queries.push(
                this.makeDefaultGenericQuery(this.config.generic_queries.length),
            );
            this.config.mix_preset = 'CUSTOM';
        },

        removeGenericQuery(idx) {
            this.normalizeGenericQueries();
            if (!Array.isArray(this.config.generic_queries)) return;
            const i = Number(idx);
            if (!Number.isInteger(i) || i < 0 || i >= this.config.generic_queries.length) return;
            this.config.generic_queries.splice(i, 1);
            this.config.mix_preset = 'CUSTOM';
        },

        // ===== Analytics Methods =====
        async loadTemplateAnalytics(templateId) {
            try {
                // Load stats, runs, and charts in parallel
                const [statsRes, runsRes] = await Promise.all([
                    fetch(`/api/dashboard/templates/${templateId}`),
                    fetch(`/api/dashboard/templates/${templateId}/runs?limit=${this.runsPageSize}&offset=0&sort_by=${this.runsSortBy}&sort_order=${this.runsSortOrder}`)
                ]);
                
                if (statsRes.ok) {
                    this.analyticsStats = await statsRes.json();
                }
                
                if (runsRes.ok) {
                    const runsData = await runsRes.json();
                    this.analyticsRuns = runsData.runs || [];
                    this.runsTotal = runsData.total_count || 0;
                }
                
                this.analyticsLoaded = true;
                
                // Load charts after DOM update
                this.$nextTick(() => {
                    this.loadDistribution();
                    this.loadScatter();
                });
            } catch (err) {
                console.error('Failed to load template analytics:', err);
            }
        },

        async loadRuns() {
            if (!this.loadedTemplate?.template_id) return;
            
            const params = new URLSearchParams({
                limit: this.runsPageSize,
                offset: (this.runsPage - 1) * this.runsPageSize,
                sort_by: this.runsSortBy,
                sort_order: this.runsSortOrder
            });
            
            try {
                const res = await fetch(`/api/dashboard/templates/${this.loadedTemplate.template_id}/runs?${params}`);
                if (res.ok) {
                    const data = await res.json();
                    this.analyticsRuns = data.runs || [];
                    this.runsTotal = data.total_count || 0;
                }
            } catch (err) {
                console.error('Failed to load runs:', err);
            }
        },

        sortRuns(field) {
            if (this.runsSortBy === field) {
                this.runsSortOrder = this.runsSortOrder === 'desc' ? 'asc' : 'desc';
            } else {
                this.runsSortBy = field;
                this.runsSortOrder = 'desc';
            }
            this.runsPage = 1;
            this.loadRuns();
        },

        prevRunsPage() {
            if (this.runsPage > 1) {
                this.runsPage--;
                this.loadRuns();
            }
        },

        nextRunsPage() {
            if (this.runsPage < Math.ceil(this.runsTotal / this.runsPageSize)) {
                this.runsPage++;
                this.loadRuns();
            }
        },

        async loadDistribution() {
            if (!this.loadedTemplate?.template_id) return;
            
            try {
                const res = await fetch(`/api/dashboard/templates/${this.loadedTemplate.template_id}/distribution?metric=${this.distributionMetric}`);
                if (res.ok) {
                    const data = await res.json();
                    this.renderDistributionChart(data);
                }
            } catch (err) {
                console.error('Failed to load distribution:', err);
            }
        },

        renderDistributionChart(data) {
            const ctx = document.getElementById('distribution-chart');
            if (!ctx) return;
            
            if (this.distributionChart) {
                this.distributionChart.destroy();
            }
            
            // Create bin labels
            const labels = [];
            for (let i = 0; i < data.counts.length; i++) {
                if (i < data.bins.length - 1) {
                    labels.push(`${data.bins[i].toFixed(0)}-${data.bins[i+1].toFixed(0)}`);
                }
            }
            
            this.distributionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Count',
                        data: data.counts,
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: 'rgb(59, 130, 246)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Count' } }
                    }
                }
            });
        },

        async loadScatter() {
            if (!this.loadedTemplate?.template_id) return;
            
            try {
                const res = await fetch(`/api/dashboard/templates/${this.loadedTemplate.template_id}/scatter?x_metric=${this.scatterX}&y_metric=${this.scatterY}`);
                if (res.ok) {
                    const data = await res.json();
                    this.scatterCorrelation = data.correlation;
                    this.renderScatterChart(data);
                }
            } catch (err) {
                console.error('Failed to load scatter:', err);
            }
        },

        renderScatterChart(data) {
            const ctx = document.getElementById('scatter-chart');
            if (!ctx) return;
            
            if (this.scatterChart) {
                this.scatterChart.destroy();
            }
            
            const points = data.data.map(p => ({ x: p.x, y: p.y }));
            
            this.scatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `${data.y_label} vs ${data.x_label}`,
                        data: points,
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: 'rgb(59, 130, 246)',
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: { title: { display: true, text: data.x_label } },
                        y: { title: { display: true, text: data.y_label } }
                    }
                }
            });
        },

        // Analytics formatting helpers
        formatNumber(val, decimals = 0) {
            if (val === null || val === undefined) return 'N/A';
            return Number(val).toLocaleString(undefined, { 
                minimumFractionDigits: decimals, 
                maximumFractionDigits: decimals 
            });
        },

        normalizeMixPct(field) {
            const val = Number(this.config[field]);
            this.config[field] = Number.isFinite(val) ? parseFloat(val.toFixed(2)) : 0;
        },

        formatLatency(val) {
            if (val === null || val === undefined) return 'N/A';
            if (val < 1) return val.toFixed(2) + 'ms';
            if (val < 1000) return val.toFixed(1) + 'ms';
            return (val / 1000).toFixed(2) + 's';
        },

        formatPercent(val) {
            if (val === null || val === undefined) return 'N/A';
            return (val * 100).toFixed(2) + '%';
        },

        formatDateTime(val) {
            if (!val) return 'N/A';
            return new Date(val).toLocaleString();
        },

        formatDuration(seconds) {
            if (!seconds) return '-';
            if (seconds < 60) return seconds.toFixed(0) + 's';
            if (seconds < 3600) return (seconds / 60).toFixed(1) + 'm';
            return (seconds / 3600).toFixed(1) + 'h';
        },

        getStabilityTextClass(badge) {
            const classes = {
                'very_stable': 'text-emerald-600',
                'stable': 'text-blue-600',
                'moderate': 'text-amber-600',
                'volatile': 'text-red-600',
            };
            return classes[badge] || 'text-gray-600';
        },

        getStabilityLabel(badge) {
            const labels = {
                'very_stable': 'Very Stable',
                'stable': 'Stable',
                'moderate': 'Moderate',
                'volatile': 'Volatile',
                'unknown': 'Unknown'
            };
            return labels[badge] || badge || 'Unknown';
        },
        // ===== End Analytics Methods =====

        applyMixPreset(preset) {
            const p = String(preset || '').trim().toUpperCase();
            const presets = {
                READ_ONLY: { custom_point_lookup_pct: 50, custom_range_scan_pct: 50, custom_insert_pct: 0, custom_update_pct: 0 },
                WRITE_ONLY: { custom_point_lookup_pct: 0, custom_range_scan_pct: 0, custom_insert_pct: 70, custom_update_pct: 30 },
                READ_HEAVY: { custom_point_lookup_pct: 40, custom_range_scan_pct: 40, custom_insert_pct: 15, custom_update_pct: 5 },
                WRITE_HEAVY: { custom_point_lookup_pct: 10, custom_range_scan_pct: 10, custom_insert_pct: 60, custom_update_pct: 20 },
                MIXED: { custom_point_lookup_pct: 25, custom_range_scan_pct: 25, custom_insert_pct: 35, custom_update_pct: 15 },
            };

            // Always persist CUSTOM workloads; presets only affect weights.
            this.config.workload_type = 'CUSTOM';

            if (p === 'CUSTOM') {
                this.config.mix_preset = 'CUSTOM';
                return;
            }
            const w = presets[p];
            if (!w) {
                this.config.mix_preset = 'CUSTOM';
                return;
            }
            // Presets apply to shortcut weights; reset GENERIC_SQL weights.
            this.normalizeGenericQueries();
            this.config.generic_queries = this.config.generic_queries.map((q, idx) => ({
                ...this.normalizeGenericQuery(q, idx),
                weight_pct: 0,
            }));
            this.config.custom_point_lookup_pct = w.custom_point_lookup_pct;
            this.config.custom_range_scan_pct = w.custom_range_scan_pct;
            this.config.custom_insert_pct = w.custom_insert_pct;
            this.config.custom_update_pct = w.custom_update_pct;
            this.config.mix_preset = p;
        },

        syncMixPresetFromWeights() {
            const hasWeightedGeneric = Array.isArray(this.config.generic_queries)
                && this.config.generic_queries.some(
                    (q) => Number((q && q.weight_pct) || 0) > 0,
                );
            if (hasWeightedGeneric) {
                this.config.mix_preset = 'CUSTOM';
                return;
            }
            const presets = {
                READ_ONLY: { custom_point_lookup_pct: 50, custom_range_scan_pct: 50, custom_insert_pct: 0, custom_update_pct: 0 },
                WRITE_ONLY: { custom_point_lookup_pct: 0, custom_range_scan_pct: 0, custom_insert_pct: 70, custom_update_pct: 30 },
                READ_HEAVY: { custom_point_lookup_pct: 40, custom_range_scan_pct: 40, custom_insert_pct: 15, custom_update_pct: 5 },
                WRITE_HEAVY: { custom_point_lookup_pct: 10, custom_range_scan_pct: 10, custom_insert_pct: 60, custom_update_pct: 20 },
                MIXED: { custom_point_lookup_pct: 25, custom_range_scan_pct: 25, custom_insert_pct: 35, custom_update_pct: 15 },
            };

            const weights = {
                custom_point_lookup_pct: Number(this.config.custom_point_lookup_pct || 0),
                custom_range_scan_pct: Number(this.config.custom_range_scan_pct || 0),
                custom_insert_pct: Number(this.config.custom_insert_pct || 0),
                custom_update_pct: Number(this.config.custom_update_pct || 0),
            };

            for (const [k, v] of Object.entries(presets)) {
                const match =
                    weights.custom_point_lookup_pct === v.custom_point_lookup_pct &&
                    weights.custom_range_scan_pct === v.custom_range_scan_pct &&
                    weights.custom_insert_pct === v.custom_insert_pct &&
                    weights.custom_update_pct === v.custom_update_pct;
                if (match) {
                    this.config.mix_preset = k;
                    return;
                }
            }
            this.config.mix_preset = 'CUSTOM';
        },

        ensureCanonicalWorkloadConfig() {
            // Canonical: templates always store CUSTOM SQL + weights.
            this.config.workload_type = 'CUSTOM';

            // Backfill mix_preset (UI helper).
            if (this.config.mix_preset == null) {
                this.config.mix_preset = 'CUSTOM';
            }
            if (!this.config.scaling || typeof this.config.scaling !== 'object') {
                this.config.scaling = {};
            }
            if (!String(this.config.scaling.mode || '').trim()) {
                this.config.scaling.mode = 'AUTO';
            }
            if (this.config.scaling.min_workers == null || String(this.config.scaling.min_workers).trim() === '') {
                this.config.scaling.min_workers = 1;
            }
            if (String(this.config.scaling.max_workers || '').trim() === '' || Number(this.config.scaling.max_workers) === -1) {
                this.config.scaling.max_workers = null;
            }
            if (this.config.scaling.min_connections == null || String(this.config.scaling.min_connections).trim() === '') {
                this.config.scaling.min_connections = 1;
            }
            if (String(this.config.scaling.max_connections || '').trim() === '' || Number(this.config.scaling.max_connections) === -1) {
                this.config.scaling.max_connections = null;
            }
            const scalingMode = String(this.config.scaling.mode || 'AUTO').trim().toUpperCase();
            if (!['AUTO', 'BOUNDED', 'FIXED'].includes(scalingMode)) {
                this.config.scaling.mode = 'AUTO';
            }

            // Initialize guardrails (used by AUTO and BOUNDED modes)
            if (!this.config.guardrails || typeof this.config.guardrails !== 'object') {
                this.config.guardrails = {};
            }
            // Migrate legacy autoscale_* fields to guardrails
            if (this.config.autoscale_max_cpu_percent != null && this.config.guardrails.max_cpu_percent == null) {
                this.config.guardrails.max_cpu_percent = Number(this.config.autoscale_max_cpu_percent);
            }
            if (this.config.autoscale_max_memory_percent != null && this.config.guardrails.max_memory_percent == null) {
                this.config.guardrails.max_memory_percent = Number(this.config.autoscale_max_memory_percent);
            }
            // Set defaults for guardrails
            if (this.config.guardrails.enabled == null) {
                this.config.guardrails.enabled = true;
            }
            if (!Number.isFinite(Number(this.config.guardrails.max_cpu_percent))) {
                this.config.guardrails.max_cpu_percent = 80;
            }
            if (!Number.isFinite(Number(this.config.guardrails.max_memory_percent))) {
                this.config.guardrails.max_memory_percent = 85;
            }

            const defaults = {
                custom_point_lookup_query: 'Use AI Adjust or enter sql manually.',
                custom_range_scan_query: 'Use AI Adjust or enter sql manually.',
                custom_insert_query: 'Use AI Adjust or enter sql manually.',
                custom_update_query: 'Use AI Adjust or enter sql manually.',
            };

            // Backfill SQL strings if missing.
            for (const k of ['custom_point_lookup_query', 'custom_range_scan_query', 'custom_insert_query', 'custom_update_query']) {
                if (!String(this.config[k] || '').trim()) {
                    this.config[k] = defaults[k];
                }
            }

            // Backfill weight fields if missing (use MIXED if everything is zero).
            const pctKeys = ['custom_point_lookup_pct', 'custom_range_scan_pct', 'custom_insert_pct', 'custom_update_pct'];
            for (const k of pctKeys) {
                const n = Number(this.config[k]);
                this.config[k] = Number.isFinite(n) ? n : 0;
            }
            this.normalizeGenericQueries();
            if (this.isInteractiveTable(this.config.table_type)) {
                for (const q of this.config.generic_queries) {
                    const op = String(q?.operation_type || '').trim().toUpperCase();
                    if (op === 'WRITE') {
                        q.weight_pct = 0;
                    }
                }
            }
            if (this.mixTotal() === 0) {
                this.applyMixPreset('MIXED');
            } else {
                this.syncMixPresetFromWeights();
            }

            // Backfill target keys to -1 (disabled).
            for (const k of [
                'target_point_lookup_p95_latency_ms',
                'target_range_scan_p95_latency_ms',
                'target_insert_p95_latency_ms',
                'target_update_p95_latency_ms',
                'target_point_lookup_p99_latency_ms',
                'target_range_scan_p99_latency_ms',
                'target_insert_p99_latency_ms',
                'target_update_p99_latency_ms',
                'target_point_lookup_error_rate_pct',
                'target_range_scan_error_rate_pct',
                'target_insert_error_rate_pct',
                'target_update_error_rate_pct',
            ]) {
                if (this.config[k] == null || String(this.config[k]).trim() === '') {
                    this.config[k] = -1;
                }
            }

        },

        nextTickAsync() {
            return new Promise((resolve) => this.$nextTick(resolve));
        },

        forceSelectValue(id, value) {
            const el = document.getElementById(id);
            if (!el) return;
            el.value = String(value || '');
        },

        formatWarehouseOption(wh) {
            // Format: WH_NAME (Gen1/2, Size, MCW 1-X?, QAS?)
            const gen = wh.resource_constraint === 'STANDARD_GEN_2' ? 'Gen2' : 'Gen1';
            let parts = [gen, wh.size];
            
            // Add MCW only if multi-cluster is enabled (max > 1)
            if (wh.max_cluster_count > 1) {
                parts.push(`MCW ${wh.min_cluster_count}-${wh.max_cluster_count}`);
            }
            
            // Add QAS only if enabled
            if (wh.enable_query_acceleration) {
                parts.push('QAS');
            }
            
            return `${wh.name} (${parts.join(', ')})`;
        },

        async onTableTypeChanged() {
            const tableType = String(this.config.table_type || '').trim().toUpperCase();
            const isPostgres = tableType === 'POSTGRES';

            if (isPostgres) {
                // Avoid persisting/using a Snowflake execution warehouse for Postgres templates.
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            }

            // Interactive tables do NOT support DML (INSERT, UPDATE, DELETE).
            // Only INSERT OVERWRITE is allowed (not supported in benchmark workloads).
            // Auto-switch to READ_ONLY and zero out INSERT/UPDATE.
            if (this.isInteractiveTable(tableType)) {
                this.config.custom_insert_pct = 0;
                this.config.custom_update_pct = 0;
                this.config.custom_insert_query = '';
                this.config.custom_update_query = '';
                this.normalizeGenericQueries();
                for (const q of this.config.generic_queries) {
                    const op = String(q?.operation_type || '').trim().toUpperCase();
                    if (op === 'WRITE') {
                        q.weight_pct = 0;
                    }
                }
                this.applyMixPreset('READ_ONLY');
            }

            await this.loadCatalog();
        },

        objectDisplayName(obj) {
            // Generate display name with type prefix: "STD: TABLE_NAME", "HYB: TABLE_NAME", etc.
            const detectedType = String(obj?.detected_type || '').toUpperCase();
            const name = obj?.name || '';
            let prefix = '';
            if (detectedType === 'STANDARD') prefix = 'STD:';
            else if (detectedType === 'HYBRID') prefix = 'HYB:';
            else if (detectedType === 'DYNAMIC') prefix = 'DYN:';
            else if (detectedType === 'INTERACTIVE') prefix = 'INT:';
            else if (detectedType === 'VIEW') prefix = 'VIEW:';
            else if (detectedType === 'TABLE') prefix = 'TBL:';  // For Postgres tables
            return prefix ? `${prefix} ${name}` : name;
        },

        onTableSelected() {
            // When user selects a table, auto-set config.table_type from detected_type
            const tableName = String(this.config.table_name || '').trim().toUpperCase();
            if (!tableName) {
                this.detectedTableType = null;
                return;
            }

            const obj = (this.availableObjects || []).find(
                (o) => String(o?.name || '').toUpperCase() === tableName
            );

            if (!obj) {
                this.detectedTableType = null;
                return;
            }

            const detectedType = String(obj.detected_type || '').toUpperCase();
            this.detectedTableType = detectedType;

            // Map detected_type to config.table_type
            // For Snowflake: STANDARD, HYBRID, DYNAMIC, INTERACTIVE, VIEW -> use as table_type (VIEW uses STANDARD)
            // For Postgres: TABLE, VIEW -> keep current Postgres table_type
            const isPostgresFilter = this.objectTypeFilter === 'POSTGRES';
            
            if (isPostgresFilter) {
                // Keep the Postgres table_type, don't change it
                return;
            }

            // For Snowflake objects, set table_type based on detected type
            if (detectedType === 'HYBRID') {
                this.config.table_type = 'HYBRID';
            } else if (detectedType === 'DYNAMIC') {
                this.config.table_type = 'DYNAMIC';
                // Dynamic tables don't support DML (they're materialized views)
                this.config.custom_insert_pct = 0;
                this.config.custom_update_pct = 0;
                this.applyMixPreset('READ_ONLY');
            } else if (detectedType === 'INTERACTIVE') {
                this.config.table_type = 'INTERACTIVE';
                // Interactive tables don't support DML in this benchmark tool
                this.config.custom_insert_pct = 0;
                this.config.custom_update_pct = 0;
                this.applyMixPreset('READ_ONLY');
            } else {
                // STANDARD or VIEW - use STANDARD table_type
                this.config.table_type = 'STANDARD';
            }
        },

        // Called when the connection dropdown changes
        async onConnectionChanged() {
            const conn = this.getSelectedConnection();
            if (!conn) {
                // No connection selected - reset everything
                this.objectTypeFilter = 'ALL_SNOWFLAKE';
                this.config.table_type = 'STANDARD';
                this.config.database = '';
                this.config.schema = '';
                this.config.table_name = '';
                this.availableDatabases = [];
                this.availableSchemas = [];
                this.availableObjects = [];
                return;
            }

            const isPostgres = conn.connection_type === 'POSTGRES';

            // Clear existing selections when switching connections
            this.config.database = '';
            this.config.schema = '';
            this.config.table_name = '';
            this.availableDatabases = [];
            this.availableSchemas = [];
            this.availableObjects = [];
            this.detectedTableType = null;

            if (isPostgres) {
                // For Postgres connections, set filter and table type to POSTGRES
                this.objectTypeFilter = 'POSTGRES';
                this.config.table_type = 'POSTGRES';
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            } else {
                // For Snowflake connections, default to ALL_SNOWFLAKE filter
                this.objectTypeFilter = 'ALL_SNOWFLAKE';
                this.config.table_type = 'STANDARD';
            }

            // Reload the catalog for the new connection
            await this.loadCatalog();
        },

        async onObjectTypeFilterChanged() {
            const filter = String(this.objectTypeFilter || 'ALL_SNOWFLAKE').toUpperCase();
            const isPostgres = filter === 'POSTGRES';
            const wasPostgres = this.isPostgresFamilyTableType(this.config.table_type);
            const isConnectionSwitch = isPostgres !== wasPostgres;

            // Set table_type for Postgres connections
            if (isPostgres) {
                this.config.table_type = filter;
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            } else {
                // For Snowflake filters, set default table_type (will be auto-detected on selection)
                this.config.table_type = 'STANDARD';
            }

            // Only clear database/schema when switching between Postgres and Snowflake
            // Keep them when switching between Snowflake table types
            if (isConnectionSwitch) {
                this.config.database = '';
                this.config.schema = '';
                this.availableDatabases = [];
                this.availableSchemas = [];
            }
            
            // Always clear table selection and reload objects
            this.config.table_name = '';
            this.detectedTableType = null;
            this.availableObjects = [];

            await this.loadCatalog();
        },

        async loadCatalog() {
            // Capture saved values before any async operations (x-model can clear values when options aren't rendered yet)
            const savedDatabase = String(this.config.database || '').trim();
            const savedSchema = String(this.config.schema || '').trim();
            const savedTableName = String(this.config.table_name || '').trim();
            const isEditingTemplate = this.mode === 'edit' || this.mode === 'view';

            // Don't load catalog until a connection is selected
            if (!this.config.connection_id) {
                this.availableDatabases = [];
                this.availableSchemas = [];
                this.availableObjects = [];
                return;
            }

            try {
                const t = String(this.config.table_type || '').trim().toLowerCase();
                let url = `/api/catalog/databases?table_type=${encodeURIComponent(t)}`;
                // Pass connection_id for future multi-connection support
                if (this.config.connection_id) {
                    url += `&connection_id=${encodeURIComponent(this.config.connection_id)}`;
                }
                const dbResp = await fetch(url);
                if (!dbResp.ok) {
                    const errPayload = await dbResp.json().catch(() => ({}));
                    const detail = errPayload?.detail || `HTTP ${dbResp.status}`;
                    window.toast.error(`Failed to load databases: ${detail}`);
                    this.availableDatabases = [];
                    return;
                }
                const dbs = await dbResp.json();
                this.availableDatabases = dbs || [];

                const normalize = (v) => String(v || '').trim().toUpperCase();

                // Pick desired database:
                // - If editing template, try to match saved database
                // - Else fall back to first available
                let desiredDb = '';
                const selectedNorm = normalize(savedDatabase);
                if (selectedNorm) {
                    const match = (this.availableDatabases || []).find(
                        (d) => normalize(d?.name) === selectedNorm,
                    );
                    desiredDb = match?.name || '';
                }
                if (!desiredDb && this.availableDatabases.length > 0 && !isEditingTemplate) {
                    // Only auto-select first database for new templates
                    desiredDb = this.availableDatabases[0].name;
                }

                // Important: set x-model value only after options are rendered, otherwise the browser may keep
                // showing the placeholder (and can even sync "" back into the model).
                await this.nextTickAsync();
                await this.nextTickAsync();

                this.config.database = desiredDb;

                // Force DOM select value to match once options exist.
                await this.nextTickAsync();
                this.forceSelectValue('database-select', desiredDb);

                // Restore saved selections in case x-model cleared them while options were unavailable.
                if (savedSchema) {
                    this.config.schema = savedSchema;
                }
                if (savedTableName) {
                    this.config.table_name = savedTableName;
                }

                // Pass preserveSelection=true when editing to keep saved schema/table.
                await this.onDatabaseChanged(isEditingTemplate);
            } catch (e) {
                console.warn('Failed to load catalog:', e);
                window.toast.error('Failed to load catalog: ' + (e?.message || e));
                this.availableDatabases = [];
                this.availableSchemas = [];
                this.availableObjects = [];
                // Don't clear saved selections on failure in edit/view; allow the user to retry by changing type/db.
                if (!isEditingTemplate) {
                    this.config.database = '';
                    this.config.schema = '';
                    this.config.table_name = '';
                }
            }
        },

        async onDatabaseChanged(preserveSelection = false) {
            const savedSchema = String(this.config.schema || '').trim();
            const savedTableName = String(this.config.table_name || '').trim();
            this.availableSchemas = [];
            this.availableObjects = [];

            const db = String(this.config.database || '').trim();
            if (!db) {
                this.config.schema = '';
                this.config.table_name = '';
                return;
            }

            try {
                const t = String(this.config.table_type || '').trim().toLowerCase();
                let url =
                    `/api/catalog/schemas?table_type=${encodeURIComponent(t)}` +
                    `&database=${encodeURIComponent(db)}`;
                // Pass connection_id for Postgres connections
                if (this.config.connection_id) {
                    url += `&connection_id=${encodeURIComponent(this.config.connection_id)}`;
                }
                const resp = await fetch(url);
                if (!resp.ok) {
                    const errPayload = await resp.json().catch(() => ({}));
                    const detail = errPayload?.detail || `HTTP ${resp.status}`;
                    window.toast.error(`Failed to load schemas: ${detail}`);
                    this.availableSchemas = [];
                    this.availableObjects = [];
                    if (!preserveSelection) {
                        this.config.schema = '';
                        this.config.table_name = '';
                    }
                    return;
                }
                const schemas = await resp.json();
                this.availableSchemas = schemas || [];

                const normalize = (v) => String(v || '').trim().toUpperCase();
                const curNorm = normalize(savedSchema);
                const match = (this.availableSchemas || []).find(
                    (s) => normalize(s?.name) === curNorm,
                );

                // Important: set x-model value only after options are rendered.
                await this.nextTickAsync();
                await this.nextTickAsync();

                if (match) {
                    // Match found: use exact name from API (fixes case mismatch with dropdown)
                    this.config.schema = match.name;
                } else if (!preserveSelection && this.availableSchemas.length > 0) {
                    // No match and not preserving: fall back to first available
                    this.config.schema = this.availableSchemas[0].name;
                } else {
                    // No match found: clear (saved schema doesn't exist anymore)
                    this.config.schema = '';
                }

                // Force DOM select value to match once options exist.
                await this.nextTickAsync();
                this.forceSelectValue('schema-select', this.config.schema);

                // Restore saved table selection before loading objects (in case x-model cleared it).
                if (savedTableName) {
                    this.config.table_name = savedTableName;
                }

                await this.onSchemaChanged(preserveSelection);
            } catch (e) {
                console.warn('Failed to load schemas:', e);
                window.toast.error('Failed to load schemas: ' + (e?.message || e));
                this.availableSchemas = [];
                this.availableObjects = [];
                if (!preserveSelection) {
                    this.config.schema = '';
                    this.config.table_name = '';
                }
            }
        },

        async onSchemaChanged(preserveSelection = false) {
            const savedTableName = String(this.config.table_name || '').trim();
            this.availableObjects = [];
            this.detectedTableType = null;

            const db = String(this.config.database || '').trim();
            const schema = String(this.config.schema || '').trim();
            if (!db || !schema) {
                this.config.table_name = '';
                return;
            }

            try {
                const t = String(this.config.table_type || '').trim().toLowerCase();
                let url =
                    `/api/catalog/objects?table_type=${encodeURIComponent(t)}` +
                    `&database=${encodeURIComponent(db)}` +
                    `&schema=${encodeURIComponent(schema)}`;
                
                // Pass connection_id for Postgres connections
                if (this.config.connection_id) {
                    url += `&connection_id=${encodeURIComponent(this.config.connection_id)}`;
                }
                
                // Add filter_type param for Snowflake when a specific filter is selected
                const filter = String(this.objectTypeFilter || 'ALL_SNOWFLAKE').toUpperCase();
                const isPostgres = filter === 'POSTGRES';
                if (!isPostgres && filter !== 'ALL_SNOWFLAKE') {
                    url += `&filter_type=${encodeURIComponent(filter)}`;
                }
                
                const resp = await fetch(url);
                if (!resp.ok) {
                    const errPayload = await resp.json().catch(() => ({}));
                    const detail = errPayload?.detail || `HTTP ${resp.status}`;
                    window.toast.error(`Failed to load tables: ${detail}`);
                    this.availableObjects = [];
                    this.config.table_name = '';
                    return;
                }
                const objs = await resp.json();
                this.availableObjects = objs || [];

                const normalize = (v) => String(v || '').trim().toUpperCase();
                const curNorm = normalize(savedTableName);
                const match = (this.availableObjects || []).find(
                    (o) => normalize(o?.name) === curNorm,
                );

                // Important: set x-model value only after options are rendered.
                await this.nextTickAsync();
                await this.nextTickAsync();

                if (match) {
                    // Match found: use exact name from API (fixes case mismatch with dropdown)
                    this.config.table_name = match.name;
                    // Set detected type for the matched table
                    this.detectedTableType = String(match.detected_type || '').toUpperCase();
                } else {
                    // No match found: clear (saved table doesn't exist or not preserving)
                    // Do not auto-select a table - require explicit user selection
                    this.config.table_name = '';
                }

                // Force DOM select value to match once options exist.
                await this.nextTickAsync();
                this.forceSelectValue('table-select', this.config.table_name);
            } catch (e) {
                console.warn('Failed to load objects:', e);
                window.toast.error('Failed to load tables: ' + (e?.message || e));
                this.availableObjects = [];
                this.config.table_name = '';
            }
        },
        
        async init() {
            this.isInitializing = true;
            this.error = null;

            // Keep mix_preset in sync with weight edits.
            this.$watch('config.custom_point_lookup_pct', () => this.syncMixPresetFromWeights());
            this.$watch('config.custom_range_scan_pct', () => this.syncMixPresetFromWeights());
            this.$watch('config.custom_insert_pct', () => this.syncMixPresetFromWeights());
            this.$watch('config.custom_update_pct', () => this.syncMixPresetFromWeights());

            // Load mode UX:
            // - When switching into auto-scale mode, default Max Connections to -1 (no user cap)
            //   unless the user already set a non-default cap.
            // - When switching back to CONCURRENCY mode, ensure Concurrent Connections is >= 1.
            this._prevLoadMode = String(this.config.load_mode || 'CONCURRENCY').trim().toUpperCase();
            this.$watch('config.load_mode', (v) => {
                const next = String(v || 'CONCURRENCY').trim().toUpperCase();
                const prev = String(this._prevLoadMode || 'CONCURRENCY').trim().toUpperCase();
                if (next === 'QPS' && prev !== 'QPS') {
                    const maxConnRaw = this.config.scaling?.max_connections;
                    const maxConnSet = !(maxConnRaw == null || String(maxConnRaw).trim() === '');
                    if (!maxConnSet) {
                        const cur = Number(this.config.concurrent_connections);
                        if (!Number.isFinite(cur) || cur === 10) {
                            this.config.concurrent_connections = -1;
                            this.config.scaling.max_connections = null;
                        } else if (cur > 0) {
                            this.config.scaling.max_connections = cur;
                        }
                    }
                }
                if (next !== 'QPS' && prev === 'QPS') {
                    // FIND_MAX doesn't use concurrent_connections - it discovers the max dynamically
                    if (next === 'FIND_MAX_CONCURRENCY') {
                        this.config.concurrent_connections = null;
                    } else {
                        const cur = Number(this.config.concurrent_connections);
                        if (!Number.isFinite(cur) || cur < 1) {
                            this.config.concurrent_connections = 10;
                        }
                    }
                }
                // When switching TO FIND_MAX from any mode, clear concurrent_connections
                if (next === 'FIND_MAX_CONCURRENCY' && prev !== 'FIND_MAX_CONCURRENCY') {
                    this.config.concurrent_connections = null;
                }
                this._prevLoadMode = next;
            });

            this.$watch('config.scaling.max_connections', (v) => {
                const mode = String(this.config.load_mode || 'CONCURRENCY').trim().toUpperCase();
                if (mode !== 'QPS') return;
                const next = Number(v);
                if (!Number.isFinite(next) || next < 1) {
                    this.config.concurrent_connections = -1;
                    return;
                }
                this.config.concurrent_connections = Math.max(1, Math.round(next));
            });

            // Enforce 200 per-worker connection limit with immediate feedback
            const MAX_CONNS_PER_WORKER = 200;
            this.$watch('config.scaling.min_connections', (v) => {
                const scalingMode = String(this.config.scaling?.mode || 'AUTO').toUpperCase();
                if (scalingMode !== 'FIXED' && scalingMode !== 'BOUNDED') return;
                const val = Number(v);
                if (Number.isFinite(val) && val > MAX_CONNS_PER_WORKER) {
                    window.toast.error(`Threads/Worker capped at ${MAX_CONNS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    this.config.scaling.min_connections = MAX_CONNS_PER_WORKER;
                }
            });
            this.$watch('config.scaling.max_connections', (v, prev) => {
                const scalingMode = String(this.config.scaling?.mode || 'AUTO').toUpperCase();
                if (scalingMode !== 'BOUNDED') return;
                const val = Number(v);
                if (Number.isFinite(val) && val > MAX_CONNS_PER_WORKER) {
                    window.toast.error(`Max Threads/Worker capped at ${MAX_CONNS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    this.config.scaling.max_connections = MAX_CONNS_PER_WORKER;
                }
            });

            // Initialize guardrails defaults when switching to non-FIXED mode
            this.$watch('config.scaling.mode', (v) => {
                const mode = String(v || 'AUTO').toUpperCase();
                if (mode === 'FIXED') return;
                if (!this.config.guardrails) {
                    this.config.guardrails = {};
                }
                if (!Number.isFinite(Number(this.config.guardrails.max_cpu_percent || 0))) {
                    this.config.guardrails.max_cpu_percent = 80;
                }
                if (!Number.isFinite(Number(this.config.guardrails.max_memory_percent || 0))) {
                    this.config.guardrails.max_memory_percent = 85;
                }
            });

            // Check URL params for mode
            const urlParams = new URLSearchParams(window.location.search);
            const urlMode = urlParams.get('mode');
            if (urlMode === 'new') {
                this.mode = 'new';
            }
            if (urlMode === 'view') {
                this.mode = 'view';
                this.isReadOnly = true;
            }

            // Prefer URL-based editing (robust across reloads / desktop wrapper).
            const templateId = urlParams.get('template_id');
            if (templateId) {
                try {
                    const resp = await fetch(`/api/templates/${encodeURIComponent(templateId)}`);
                    if (resp.ok) {
                        const template = await resp.json();
                        this.loadedTemplate = template;
                        this.hasResults = (template.usage_count || 0) > 0;
                        // If template has results, it cannot be edited (force read-only).
                        // If URL mode explicitly requests view, also force read-only.
                        if (this.hasResults || this.mode === 'view') {
                            this.mode = 'view';
                            this.isReadOnly = true;
                        } else {
                            this.mode = 'edit';
                            this.isReadOnly = false;
                        }
                        // Deep merge nested objects to preserve defaults for scaling and guardrails
                        const templateConfig = template.config || {};
                        const defaultScaling = { ...this.config.scaling };
                        const defaultGuardrails = { ...this.config.guardrails };
                        this.config = { ...this.config, ...templateConfig };
                        // Restore defaults for nested objects, then overlay saved values
                        this.config.scaling = { ...defaultScaling, ...(templateConfig.scaling || {}) };
                        this.config.guardrails = { ...defaultGuardrails, ...(templateConfig.guardrails || {}) };
                        if (this.config.warehouse_name) {
                            this.config.warehouse_name = String(this.config.warehouse_name).trim();
                        }
                        // Default: if not present, treat as TRUE.
                        // Coerce to a boolean for the checkbox UI.
                        if (this.config.use_cached_result == null) {
                            this.config.use_cached_result = true;
                        } else {
                            const v = String(this.config.use_cached_result).trim().toLowerCase();
                            this.config.use_cached_result = !['0', 'false', 'no', 'off'].includes(v);
                        }
                        // Default use_pgbouncer to FALSE for Postgres connections.
                        // PgBouncer may not be available on all instances.
                        // Coerce to a boolean for the checkbox UI.
                        if (this.config.use_pgbouncer == null) {
                            this.config.use_pgbouncer = false;
                        } else {
                            const v = String(this.config.use_pgbouncer).trim().toLowerCase();
                            this.config.use_pgbouncer = !['0', 'false', 'no', 'off'].includes(v);
                        }
                        this.ensureCanonicalWorkloadConfig();
                        this.config.template_name = template.template_name;
                        this.config.description = template.description;
                        // Initialize objectTypeFilter based on loaded template's table_type
                        const tt = String(this.config.table_type || '').toUpperCase();
                        if (tt === 'POSTGRES') {
                            this.objectTypeFilter = tt;
                        } else {
                            // For Snowflake types, default to ALL_SNOWFLAKE (type will be auto-detected)
                            this.objectTypeFilter = 'ALL_SNOWFLAKE';
                        }
                        this.aiPrepResult = this.aiPrepStatusFromConfig('Loaded from template');
                        this.aiPrepError = null;
                        
                        // Load analytics if template has runs
                        if (this.hasResults) {
                            this.loadTemplateAnalytics(this.loadedTemplate.template_id);
                        }
                    } else {
                        const payload = await resp.json().catch(() => ({}));
                        const detail = payload && payload.detail ? payload.detail : null;
                        this.error =
                            (detail && (detail.message || detail.detail || detail)) ||
                            `Failed to load template (HTTP ${resp.status})`;
                        console.warn('Failed to load template by id:', templateId, resp.status, this.error);
                    }
                } catch (error) {
                    console.error('Failed to load template by id:', error);
                    this.error = error?.message || String(error);
                }
            }

            // If this is a Postgres-based template type, clear warehouse fields to avoid
            // accidentally persisting/using the results warehouse as an "execution" warehouse.
            if (this.config.table_type === 'POSTGRES') {
                this.config.warehouse_name = '';
                this.selectedWarehouseDetails = null;
            }

            // Load warehouses before enabling the form so users don't start editing
            // and then have dropdowns/details change underneath them.
            try {
                await this.loadConnections();
                await this.loadWarehouses();
                await this.loadCatalog();
            } finally {
                this.snapshotConfig();
                this.isInitializing = false;
            }
        },

        async loadConnections() {
            try {
                const resp = await fetch('/api/connections/');
                if (resp.ok) {
                    const data = await resp.json();
                    this.availableConnections = data.connections || [];
                    
                    // Capture the saved connection_id before any modifications
                    const savedConnectionId = this.config.connection_id || '';
                    
                    // If we have a saved connection_id from template, verify it exists
                    // and set the objectTypeFilter accordingly
                    if (savedConnectionId) {
                        const match = this.availableConnections.find(
                            c => c.connection_id === savedConnectionId
                        );
                        if (!match) {
                            // Connection no longer exists - clear it
                            console.warn('Saved connection_id not found:', savedConnectionId);
                            this.config.connection_id = '';
                        } else {
                            // Set objectTypeFilter based on the loaded connection's type
                            if (match.connection_type === 'POSTGRES') {
                                this.objectTypeFilter = 'POSTGRES';
                                this.config.table_type = 'POSTGRES';
                            } else {
                                // Keep existing objectTypeFilter for Snowflake (could be HYBRID, STANDARD, etc.)
                                // but ensure it's not POSTGRES
                                if (this.objectTypeFilter === 'POSTGRES') {
                                    this.objectTypeFilter = 'ALL_SNOWFLAKE';
                                }
                            }
                        }
                    }
                    
                    // If no connection selected and only one exists, auto-select it
                    if (!this.config.connection_id && this.availableConnections.length === 1) {
                        this.config.connection_id = this.availableConnections[0].connection_id;
                        // Set the appropriate filter based on connection type
                        const conn = this.availableConnections[0];
                        if (conn.connection_type === 'POSTGRES') {
                            this.objectTypeFilter = 'POSTGRES';
                            this.config.table_type = 'POSTGRES';
                        }
                    }
                    
                    // Wait for Alpine to render the options, then force the select value
                    await this.nextTickAsync();
                    await this.nextTickAsync();
                    
                    // Restore the connection_id (x-model may have cleared it while options were loading)
                    if (savedConnectionId && this.availableConnections.find(c => c.connection_id === savedConnectionId)) {
                        this.config.connection_id = savedConnectionId;
                    }
                    
                    // Force DOM select to match
                    await this.nextTickAsync();
                    this.forceSelectValue('connection-select', this.config.connection_id);
                    
                } else {
                    console.warn('Failed to load connections:', resp.status);
                    window.toast.error('Failed to load connections');
                }
            } catch (e) {
                console.error('Error loading connections:', e);
                window.toast.error('Error loading connections: ' + (e?.message || e));
            }
        },
        
        async loadWarehouses() {
            try {
                const [warehousesResp, infoResp] = await Promise.all([
                    // Exclude results warehouse from selection - it's reserved for backend operations.
                    // Warning logic below still handles templates previously saved with results warehouse.
                    fetch('/api/warehouses/?exclude_results=true'),
                    fetch('/api/info'),
                ]);
                if (warehousesResp.ok) {
                    const allWarehouses = await warehousesResp.json();
                    const info = infoResp.ok ? await infoResp.json() : {};
                    this.resultsWarehouse = String(info.results_warehouse || '').trim().toUpperCase() || null;

                    this.availableWarehouses = allWarehouses || [];

                    const normalize = (v) => String(v || '').trim().toUpperCase();

                    // Choose desired warehouse:
                    // - If template provided one and it exists, use canonical option value.
                    // - If it doesn't exist, require explicit user selection.
                    let desiredWarehouseName = '';
                    const selectedNorm = normalize(this.config.warehouse_name);
                    if (selectedNorm) {
                        const match = (this.availableWarehouses || []).find(
                            (w) => normalize(w?.name) === selectedNorm,
                        );
                        desiredWarehouseName = match?.name || '';
                    }

                    // Important: set x-model value only after options are rendered,
                    // otherwise the browser may keep showing the placeholder even though
                    // the value is set and details load correctly.
                    await this.nextTickAsync();
                    // Some browsers require an additional tick before <select> option values are stable.
                    await this.nextTickAsync();

                    this.config.warehouse_name = desiredWarehouseName;

                    // Force DOM select value to match (in case x-model updates before options settle).
                    await this.nextTickAsync();
                    const selectEl = document.getElementById('warehouse-select');
                    if (selectEl) {
                        selectEl.value = desiredWarehouseName;
                    }

                    if (!this.config.warehouse_name) {
                        this.selectedWarehouseDetails = null;
                        return;
                    }
                    await this.loadWarehouseDetails();
                } else {
                    const payload = await warehousesResp.json().catch(() => ({}));
                    const detail = payload && payload.detail ? payload.detail : null;
                    this.error =
                        (detail && (detail.message || detail.detail || detail)) ||
                        `Failed to load warehouses (HTTP ${warehousesResp.status})`;
                    console.error('Failed to load warehouses', this.error);
                }
            } catch (error) {
                console.error('Error loading warehouses:', error);
                this.error = error?.message || String(error);
            }
        },
        
        async loadWarehouseDetails() {
            if (!this.config.warehouse_name) {
                this.selectedWarehouseDetails = null;
                return;
            }
            
            try {
                const response = await fetch(
                    `/api/warehouses/${encodeURIComponent(this.config.warehouse_name)}`,
                );
                if (response.ok) {
                    this.selectedWarehouseDetails = await response.json();
                    
                    // Normalize warehouse size from Snowflake format (e.g., "X-Large") to our format (e.g., "XLARGE")
                    const sizeMap = {
                        'X-Small': 'XSMALL',
                        'Small': 'SMALL',
                        'Medium': 'MEDIUM',
                        'Large': 'LARGE',
                        'X-Large': 'XLARGE',
                        '2X-Large': '2XLARGE',
                        '3X-Large': '3XLARGE',
                        '4X-Large': '4XLARGE'
                    };
                    
                    // Auto-populate warehouse configuration
                    this.config.warehouse_size = sizeMap[this.selectedWarehouseDetails.size] || this.selectedWarehouseDetails.size;
                    this.config.multi_cluster = this.selectedWarehouseDetails.max_cluster_count > 1;
                    this.config.min_clusters = this.selectedWarehouseDetails.min_cluster_count;
                    this.config.max_clusters = this.selectedWarehouseDetails.max_cluster_count;
                    this.config.scaling_policy = this.selectedWarehouseDetails.scaling_policy || 'STANDARD';
                } else {
                    console.error('Failed to load warehouse details');
                }
            } catch (error) {
                console.error('Error loading warehouse details:', error);
            }
        },
        
        clearTemplate() {
            this.loadedTemplate = null;
            this.resetConfig();
        },
        
        addIndex() {
            // Removed: table creation (including indexes) is no longer supported.
        },
        
        removeIndex(idx) {
            // Removed: table creation (including indexes) is no longer supported.
        },
        
        async submitTest() {
            await this._saveTemplate({ prepareAfterSave: false });
        },

        async saveAndPrepare() {
            if (this.saveAndPrepareLoading) return;
            this.saveAndPrepareLoading = true;
            try {
                await this._saveTemplate({ prepareAfterSave: true });
            } finally {
                this.saveAndPrepareLoading = false;
            }
        },

        async _saveTemplate({ prepareAfterSave = false } = {}) {
            if (this.isSaving) {
                return;
            }
            if (this.isReadOnly) {
                window.toast.warning('Template is read-only and cannot be updated.');
                return;
            }
            if (!this.config.template_name) {
                window.toast.warning('Please provide a template name');
                return;
            }
            // Canonical: templates always persist CUSTOM SQL + weights.
            this.ensureCanonicalWorkloadConfig();

            const total = this.mixTotal();
            if (Math.abs(total - 100) > 0.001) {
                window.toast.warning(
                    `Mix percentages must sum to 100.00 (currently ${total.toFixed(2)}).`,
                );
                return;
            }

            // Match server validation: SQL is required when a weight > 0.
            const requiredPairs = [
                ['custom_point_lookup_pct', 'custom_point_lookup_query', 'Point Lookup'],
                ['custom_range_scan_pct', 'custom_range_scan_query', 'Range Scan'],
                ['custom_insert_pct', 'custom_insert_query', 'Insert'],
                ['custom_update_pct', 'custom_update_query', 'Update'],
            ];
            for (const [pctK, sqlK, label] of requiredPairs) {
                const pct = Number(this.config[pctK] || 0);
                const sql = String(this.config[sqlK] || '').trim();
                if (pct > 0 && !sql) {
                    window.toast.warning(`${label}: SQL is required when weight % > 0.`);
                    return;
                }
            }

            // Validate GENERIC_SQL entries.
            this.normalizeGenericQueries();
            const seenGenericIds = new Set();
            for (let i = 0; i < this.config.generic_queries.length; i++) {
                const q = this.config.generic_queries[i] || {};
                const id = String(q.id || '').trim();
                const op = String(q.operation_type || '').trim().toUpperCase();
                const weight = Number(q.weight_pct || 0);
                const sql = String(q.sql || '').trim();
                if (!id) {
                    window.toast.warning(`Generic SQL #${i + 1}: id is required.`);
                    return;
                }
                if (seenGenericIds.has(id)) {
                    window.toast.warning(`Generic SQL id '${id}' is duplicated.`);
                    return;
                }
                seenGenericIds.add(id);
                if (!['READ', 'WRITE'].includes(op)) {
                    window.toast.warning(`Generic SQL '${id}': operation_type must be READ or WRITE.`);
                    return;
                }
                if (!Number.isFinite(weight) || weight < 0 || weight > 100) {
                    window.toast.warning(`Generic SQL '${id}': weight_pct must be between 0.00 and 100.00.`);
                    return;
                }
                if (weight > 0 && !sql) {
                    window.toast.warning(`Generic SQL '${id}': SQL is required when weight % > 0.`);
                    return;
                }
                if (this.isInteractiveTable(this.config.table_type) && op === 'WRITE' && weight > 0) {
                    window.toast.warning(`Generic SQL '${id}': WRITE operations are not supported for interactive tables.`);
                    return;
                }
            }

            // Validate load mode.
            const loadMode = String(this.config.load_mode || 'CONCURRENCY').trim().toUpperCase();
            if (!['CONCURRENCY', 'QPS', 'FIND_MAX_CONCURRENCY'].includes(loadMode)) {
                window.toast.warning('Invalid load mode. Choose Fixed workers, Target throughput (QPS), or Find max.');
                return;
            }

            const scalingMode = String(this.config.scaling?.mode || 'AUTO').trim().toUpperCase();
            const minWorkers = Number(this.config.scaling?.min_workers || 1);
            const maxWorkersRaw = this.config.scaling?.max_workers;
            const maxWorkers =
                maxWorkersRaw == null || String(maxWorkersRaw).trim() === ''
                    ? null
                    : Number(maxWorkersRaw);
            const minC = Number(this.config.scaling?.min_connections || 1);
            const maxCRaw = this.config.scaling?.max_connections;
            const maxC =
                maxCRaw == null || String(maxCRaw).trim() === ''
                    ? null
                    : Number(maxCRaw);

            if (!Number.isFinite(minWorkers) || minWorkers < 1) {
                window.toast.warning('Min Workers must be >= 1.');
                return;
            }
            if (maxWorkers != null && (!Number.isFinite(maxWorkers) || maxWorkers < 1)) {
                window.toast.warning('Max Workers must be >= 1 or blank.');
                return;
            }
            if (maxWorkers != null && minWorkers > maxWorkers) {
                window.toast.warning('Min Workers must be <= Max Workers.');
                return;
            }
            if (!Number.isFinite(minC) || minC < 1) {
                window.toast.warning('Min Connections must be >= 1.');
                return;
            }
            if (maxC != null && (!Number.isFinite(maxC) || maxC < 1)) {
                window.toast.warning('Max Connections must be >= 1 or blank.');
                return;
            }
            if (maxC != null && minC > maxC) {
                window.toast.warning('Min Connections must be <= Max Connections.');
                return;
            }

            // Enforce 200 per-worker connection limit for BOUNDED and FIXED modes.
            // Each Snowflake connection spawns 3-4 internal threads, so 200 connections
            // = 600-800 threads per worker. Higher values risk OS thread exhaustion.
            const MAX_CONNECTIONS_PER_WORKER = 200;
            if (scalingMode === 'BOUNDED' || scalingMode === 'FIXED') {
                if (minC > MAX_CONNECTIONS_PER_WORKER) {
                    window.toast.error(`Threads/Worker cannot exceed ${MAX_CONNECTIONS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    return;
                }
                if (maxC != null && maxC > MAX_CONNECTIONS_PER_WORKER) {
                    window.toast.error(`Max Threads/Worker cannot exceed ${MAX_CONNECTIONS_PER_WORKER}. Each connection spawns multiple internal threads.`);
                    return;
                }
            }

            if (scalingMode === 'FIXED') {
                if (this.config.scaling?.min_workers == null || String(this.config.scaling?.min_workers).trim() === '') {
                    window.toast.warning('FIXED mode requires Min Workers.');
                    return;
                }
                if (this.config.scaling?.min_connections == null || String(this.config.scaling?.min_connections).trim() === '') {
                    window.toast.warning('FIXED mode requires Min Connections.');
                    return;
                }
            }

            if (loadMode === 'FIND_MAX_CONCURRENCY') {
                const startC = Number(this.config.start_concurrency || 5);
                const increment = Number(this.config.concurrency_increment || 10);
                const stepDur = Number(this.config.step_duration_seconds || 30);
                const maxC = Number(this.config.concurrent_connections || 100);
                if (!Number.isFinite(startC) || startC < 1) {
                    window.toast.warning('Start Concurrency must be >= 1.');
                    return;
                }
                if (!Number.isFinite(increment) || increment < 1) {
                    window.toast.warning('Concurrency Increment must be >= 1.');
                    return;
                }
                if (!Number.isFinite(stepDur) || stepDur < 10) {
                    window.toast.warning('Step Duration must be >= 10 seconds.');
                    return;
                }
                if (!Number.isFinite(maxC) || maxC < startC) {
                    window.toast.warning('Max Connections must be >= Start Concurrency.');
                    return;
                }
            }

            if (loadMode === 'QPS') {
                const targetQps = Number(this.config.target_qps || 0);
                if (!Number.isFinite(targetQps) || targetQps <= 0) {
                    window.toast.warning('Target must be a positive number.');
                    return;
                }
            }

            // Validate connection limits for Postgres based on PgBouncer setting
            const isPostgresTableType = this.isPostgresFamilyTableType(this.config.table_type);
            if (isPostgresTableType) {
                const usePgBouncer = this.config.use_pgbouncer === true;
                // Direct PostgreSQL max_connections is typically 500
                // PgBouncer can handle up to 1000 client connections (multiplexed over ~497 server connections)
                const DIRECT_POSTGRES_MAX = 500;
                const PGBOUNCER_MAX = 1000;
                const connectionLimit = usePgBouncer ? PGBOUNCER_MAX : DIRECT_POSTGRES_MAX;

                // Calculate total connections based on load mode
                let totalConnections = 0;
                if (loadMode === 'CONCURRENCY') {
                    totalConnections = Number(this.config.concurrent_connections || 0);
                } else if (loadMode === 'FIND_MAX_CONCURRENCY') {
                    totalConnections = Number(this.config.concurrent_connections || 0);
                } else if (loadMode === 'QPS' && scalingMode === 'FIXED') {
                    // For QPS mode with FIXED scaling, calculate from workers × connections
                    totalConnections = minWorkers * minC;
                }

                if (totalConnections > connectionLimit) {
                    if (usePgBouncer) {
                        window.toast.warning(
                            `Total connections (${totalConnections}) exceeds PgBouncer client limit (${PGBOUNCER_MAX}). ` +
                            `Reduce the connection count.`
                        );
                    } else {
                        window.toast.warning(
                            `Total connections (${totalConnections}) exceeds PostgreSQL max_connections (${DIRECT_POSTGRES_MAX}). ` +
                            `Enable PgBouncer to support up to ${PGBOUNCER_MAX} connections.`
                        );
                    }
                    return;
                }
            }

            // Validate guardrails for non-FIXED modes (only if enabled)
            if (scalingMode !== 'FIXED' && this.config.guardrails?.enabled !== false) {
                const maxCpu = Number(this.config.guardrails?.max_cpu_percent || 0);
                const maxMem = Number(this.config.guardrails?.max_memory_percent || 0);
                if (!Number.isFinite(maxCpu) || maxCpu <= 0 || maxCpu > 100) {
                    window.toast.warning('Max CPU % must be within (0, 100].');
                    return;
                }
                if (!Number.isFinite(maxMem) || maxMem <= 0 || maxMem > 100) {
                    window.toast.warning('Max Memory % must be within (0, 100].');
                    return;
                }
            }

            // Validate targets (SLOs). Use -1 to disable a target.
            const weights = {
                POINT_LOOKUP: Number(this.config.custom_point_lookup_pct || 0),
                RANGE_SCAN: Number(this.config.custom_range_scan_pct || 0),
                INSERT: Number(this.config.custom_insert_pct || 0),
                UPDATE: Number(this.config.custom_update_pct || 0),
            };

            const targetKeys = {
                POINT_LOOKUP: {
                    p95: 'target_point_lookup_p95_latency_ms',
                    p99: 'target_point_lookup_p99_latency_ms',
                    err: 'target_point_lookup_error_rate_pct',
                    label: 'Point Lookup',
                },
                RANGE_SCAN: {
                    p95: 'target_range_scan_p95_latency_ms',
                    p99: 'target_range_scan_p99_latency_ms',
                    err: 'target_range_scan_error_rate_pct',
                    label: 'Range Scan',
                },
                INSERT: {
                    p95: 'target_insert_p95_latency_ms',
                    p99: 'target_insert_p99_latency_ms',
                    err: 'target_insert_error_rate_pct',
                    label: 'Insert',
                },
                UPDATE: {
                    p95: 'target_update_p95_latency_ms',
                    p99: 'target_update_p99_latency_ms',
                    err: 'target_update_error_rate_pct',
                    label: 'Update',
                },
            };

            const isFiniteNumber = (v) => Number.isFinite(Number(v));

            for (const kind of Object.keys(targetKeys)) {
                const weight = Number(weights[kind] || 0);
                if (weight <= 0) continue;

                const keys = targetKeys[kind];
                const p95 = Number(this.config[keys.p95] ?? -1);
                const p99 = Number(this.config[keys.p99] ?? -1);
                const err = Number(this.config[keys.err] ?? -1);

                const p95Enabled = isFiniteNumber(p95) && p95 >= 0;
                const p99Enabled = isFiniteNumber(p99) && p99 >= 0;
                const errEnabled = isFiniteNumber(err) && err >= 0;

                if (p95Enabled) {
                    if (p95 <= 0) {
                        window.toast.warning(
                            `${keys.label}: P95 target must be > 0 (ms), or -1 to disable.`,
                        );
                        return;
                    }
                }

                if (p99Enabled) {
                    if (p99 <= 0) {
                        window.toast.warning(
                            `${keys.label}: P99 target must be > 0 (ms), or -1 to disable.`,
                        );
                        return;
                    }
                }

                if (errEnabled) {
                    if (err > 100) {
                        window.toast.warning(
                            `${keys.label}: max error % must be between 0 and 100, or -1 to disable.`,
                        );
                        return;
                    }
                }

                if (!p95Enabled && !p99Enabled && !errEnabled) {
                    // Both targets disabled: allowed.
                    continue;
                }
            }

            const tableType = String(this.config.table_type || '').trim().toUpperCase();
            const isPostgres = tableType === 'POSTGRES';

            if (!isPostgres && !String(this.config.warehouse_name || '').trim()) {
                window.toast.warning('Please select an existing warehouse');
                return;
            }

            const selectedWh = String(this.config.warehouse_name || '').trim().toUpperCase();
            if (!isPostgres && this.resultsWarehouse && selectedWh === this.resultsWarehouse) {
                window.toast.warning(
                    `This template is configured to run on ${selectedWh}, which is also your results warehouse (${this.resultsWarehouse}). Please choose a different warehouse before saving.`,
                );
                return;
            }
            
            this.isSaving = true;
            try {
                const templateData = {
                    template_name: this.config.template_name,
                    description: this.config.description || null,
                    config: this.config
                };
                
                let response;
                if (this.mode === 'edit' && this.loadedTemplate) {
                    // Update existing template
                    response = await fetch(`/api/templates/${this.loadedTemplate.template_id}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(templateData)
                    });
                } else {
                    // Create new template
                    response = await fetch('/api/templates/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(templateData)
                    });
                }
                
                if (response.ok) {
                    const createdOrUpdated = await response.json().catch(() => null);
                    const successMessage =
                        this.mode === 'edit'
                            ? 'Template updated successfully.'
                            : 'Template created successfully.';

                    // Keep the user on the configure page (no redirect). Update URL + local state.
                    if (createdOrUpdated && createdOrUpdated.template_id) {
                        this.loadedTemplate = createdOrUpdated;
                        this.hasResults = (createdOrUpdated.usage_count || 0) > 0;

                        // If the template now has results, force view mode. Otherwise edit.
                        if (this.hasResults) {
                            this.mode = 'view';
                            this.isReadOnly = true;
                        } else {
                            this.mode = 'edit';
                            this.isReadOnly = false;
                        }

                        this.config = { ...this.config, ...(createdOrUpdated.config || {}) };
                        this.ensureCanonicalWorkloadConfig();
                        this.config.template_name = createdOrUpdated.template_name;
                        this.config.description = createdOrUpdated.description;
                        this.aiPrepResult = this.aiPrepStatusFromConfig('Loaded from template');
                        this.aiPrepError = null;

                        // Ensure URL has template_id so refresh/reload preserves state.
                        try {
                            const url = new URL(window.location.href);
                            url.searchParams.set('template_id', String(createdOrUpdated.template_id));
                            // Clear mode overrides unless we're explicitly in view mode.
                            if (this.mode === 'view') {
                                url.searchParams.set('mode', 'view');
                            } else {
                                url.searchParams.delete('mode');
                            }
                            window.history.replaceState({}, '', url.pathname + url.search);
                        } catch (e) {
                            console.warn('Failed to update URL after save:', e);
                        }

                        this.snapshotConfig();
                    }

                    if (prepareAfterSave) {
                        // Run preparation immediately after save, and show results in-place.
                        // Defer toast until metadata refresh is complete.
                        await this.prepareAiWorkload();
                        if (this.aiPrepError) {
                            // Template saved, but metadata refresh failed.
                            const savedMsg = this.mode === 'edit' ? 'Template updated' : 'Template created';
                            const isValidationError = this.aiPrepError.includes('validation failed');
                            if (isValidationError) {
                                window.toast.error(savedMsg + ', but SQL validation failed. Check your GENERIC_SQL queries.');
                                // Also show the detailed error
                                window.toast.warning(this.aiPrepError, { timeoutMs: 10000 });
                            } else {
                                window.toast.warning(
                                    savedMsg + ', but table metadata refresh failed: ' + this.aiPrepError,
                                );
                            }
                        } else {
                            window.toast.success(
                                this.mode === 'edit'
                                    ? 'Template updated and table metadata refreshed.'
                                    : 'Template created and table metadata collected.',
                            );
                        }
                    } else {
                        window.toast.success(successMessage);
                    }
                } else {
                    const error = await response.json().catch(() => ({}));
                    const detail = error && error.detail ? error.detail : null;
                    
                    // Check for PgBouncer-related errors and show helpful message with docs link
                    if (detail && (detail.error === 'pgbouncer_extension_missing' || detail.error === 'pgbouncer_privileged_user_not_allowed')) {
                        window.toast.error(detail.message);
                        if (detail.docs_url) {
                            window.toast.info(`See docs: ${detail.docs_url}`, { timeoutMs: 15000 });
                        }
                    } else {
                        window.toast.error(
                            'Error saving template: ' +
                                (detail?.message || detail?.detail || detail || 'Unknown error'),
                        );
                    }
                }
            } catch (error) {
                console.error('Failed to save template:', error);
                window.toast.error('Failed to save template: ' + (error?.message || error));
            } finally {
                this.isSaving = false;
            }
        },

        async reloadTemplate() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) return;
            try {
                const resp = await fetch(`/api/templates/${encodeURIComponent(this.loadedTemplate.template_id)}`);
                if (!resp.ok) {
                    return;
                }
                const template = await resp.json();
                this.loadedTemplate = template;
                this.hasResults = (template.usage_count || 0) > 0;
                // Deep merge nested objects to preserve defaults for scaling and guardrails
                const templateConfig = template.config || {};
                const defaultScaling = { ...this.config.scaling };
                const defaultGuardrails = { ...this.config.guardrails };
                this.config = { ...this.config, ...templateConfig };
                this.config.scaling = { ...defaultScaling, ...(templateConfig.scaling || {}) };
                this.config.guardrails = { ...defaultGuardrails, ...(templateConfig.guardrails || {}) };
                // Coerce use_pgbouncer to boolean (default FALSE - PgBouncer may not be available)
                if (this.config.use_pgbouncer == null) {
                    this.config.use_pgbouncer = false;
                } else {
                    const v = String(this.config.use_pgbouncer).trim().toLowerCase();
                    this.config.use_pgbouncer = !['0', 'false', 'no', 'off'].includes(v);
                }
                this.ensureCanonicalWorkloadConfig();
                this.config.template_name = template.template_name;
                this.config.description = template.description;
                        this.aiPrepResult = this.aiPrepStatusFromConfig('Loaded from template');
                        this.aiPrepError = null;
                        
                        // Load analytics if template has runs
                        if (this.hasResults) {
                            this.loadTemplateAnalytics(templateId);
                        }
            } catch (e) {
                console.warn('Failed to reload template:', e);
            }
        },

        async prepareAiWorkload() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) {
                window.toast.warning('Save the template first, then run AI preparation.');
                return;
            }
            if (this.hasResults) {
                window.toast.warning(
                    'This template has results and cannot be modified. Copy it first.',
                );
                return;
            }
            this.aiPrepLoading = true;
            this.aiPrepError = null;
            try {
                const resp = await fetch(`/api/templates/${encodeURIComponent(this.loadedTemplate.template_id)}/ai/prepare`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({}),
                });
                const payload = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const detail = payload && payload.detail ? payload.detail : null;
                    this.aiPrepError =
                        (detail && (detail.message || detail.detail || detail)) ||
                        `Failed (HTTP ${resp.status})`;
                    return;
                }
                this.aiPrepResult = payload;
                // Normalize the response into the same UI shape we use for template-loaded status.
                if (this.aiPrepResult && typeof this.aiPrepResult === 'object') {
                    this.aiPrepResult = {
                        prepared: Boolean(this.aiPrepResult.pool_id),
                        prepared_at: null,
                        pool_id: this.aiPrepResult.pool_id || null,
                        key_column: this.aiPrepResult.key_column || null,
                        time_column: this.aiPrepResult.time_column || null,
                        range_mode: this.aiPrepResult.range_mode || null,
                        pools: this.aiPrepResult.pools || null,
                        cortex_available: Boolean(this.aiPrepResult.ai_available),
                        cortex_error: this.aiPrepResult.ai_error || null,
                    };
                }
                // Reload template config so persisted metadata is reflected locally.
                await this.reloadTemplate();
            } catch (e) {
                this.aiPrepError = e?.message || String(e);
            } finally {
                this.aiPrepLoading = false;
            }
        },

        async updateTableMetadata() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) {
                window.toast.warning('No template loaded.');
                return;
            }
            if (this.updateMetadataLoading) return;

            this.updateMetadataLoading = true;
            this.aiPrepError = null;
            try {
                const resp = await fetch(
                    `/api/templates/${encodeURIComponent(this.loadedTemplate.template_id)}/ai/prepare`,
                    { method: 'POST' }
                );
                const payload = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const detail = payload?.detail;
                    const errorMsg = typeof detail === 'string' 
                        ? detail 
                        : (detail?.message || detail?.detail || JSON.stringify(detail) || 'Failed to update metadata');
                    throw new Error(errorMsg);
                }
                
                // Update local config with new ai_workload data
                if (payload.ai_workload) {
                    this.config.ai_workload = payload.ai_workload;
                }
                // Reload the template to get fresh data
                await this.reloadTemplate();
                window.toast.success('Table metadata updated successfully.');
            } catch (e) {
                console.error('Failed to update table metadata:', e);
                this.aiPrepError = e.message || String(e);
                window.toast.error(`Failed to update table metadata: ${e.message || e}`);
            } finally {
                this.updateMetadataLoading = false;
            }
        },

        async prepareTemplate() {
            if (!this.loadedTemplate || !this.loadedTemplate.template_id) {
                window.toast.warning('No template loaded.');
                return;
            }
            if (this.prepareTemplateLoading) return;

            if (this.isDirty()) {
                const choice = await window.toast.confirm(
                    'You have unsaved changes. Save before running?',
                    {
                        confirmText: 'Save & Run',
                        cancelText: 'Run Without Saving',
                        confirmVariant: 'primary',
                        timeoutMs: 15000,
                    }
                );
                if (choice) {
                    await this._saveTemplate({ prepareAfterSave: true });
                    this.snapshotConfig();
                }
            }

            const tableType = String(this.config.table_type || '').toUpperCase();
            const isPostgres = tableType === 'POSTGRES';

            this.prepareTemplateLoading = true;
            try {
                // For Snowflake-executed templates, enforce that the execution warehouse
                // isn't the same as the results warehouse.
                if (!isPostgres) {
                    const infoResp = await fetch('/api/info');
                    const info = infoResp.ok ? await infoResp.json() : {};
                    const resultsWarehouse = String(info.results_warehouse || '').toUpperCase();
                    const execWarehouse = String(this.config.warehouse_name || '').toUpperCase();

                    if (resultsWarehouse && execWarehouse && resultsWarehouse === execWarehouse) {
                        window.toast.warning(
                            `This template is configured to run on ${execWarehouse}, which is also your results warehouse (${resultsWarehouse}). Please edit the template and choose a different warehouse before running.`
                        );
                        return;
                    }
                }

            // Use unified endpoint for all scaling modes (AUTO, BOUNDED, FIXED)
            const endpoint = `/api/tests/from-template/${encodeURIComponent(this.loadedTemplate.template_id)}`;
            const resp = await fetch(endpoint, { method: 'POST' });
                if (!resp.ok) {
                    const err = await resp.json().catch(() => ({}));
                    const detail = err.detail;
                    const errorMsg = typeof detail === 'string' 
                        ? detail 
                        : (detail?.message || detail?.detail || JSON.stringify(detail) || 'Failed to prepare test');
                    throw new Error(errorMsg);
                }
                const data = await resp.json();
                window.location.href = data.dashboard_url || `/dashboard/${data.test_id}`;
            } catch (e) {
                console.error('Failed to prepare template:', e);
                window.toast.error(`Failed to prepare test: ${e.message || e}`);
            } finally {
                this.prepareTemplateLoading = false;
            }
        },

        async aiAdjustCustomSql() {
            // Preview-only: updates the 4 custom SQL statements + %s in the UI.
            // No DB writes occur until the user saves the template.
            if (!this.hasSelectedTable()) {
                window.toast.warning('Select database, schema, and table first.');
                return;
            }
            this.aiSqlAdjustLoading = true;
            try {
                const resp = await fetch('/api/templates/ai/adjust-sql', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ config: this.config }),
                });
                const payload = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    const detail = payload && payload.detail ? payload.detail : null;
                    window.toast.error(
                        'AI SQL adjustment failed: ' +
                            (detail?.message || detail?.detail || detail || `HTTP ${resp.status}`),
                    );
                    return;
                }

                const level = String(payload.toast_level || 'success').toLowerCase();
                const shouldApplyMix = level === 'warning';

                // Store Interactive Table metadata
                this.interactiveTableClusterBy = payload.cluster_by || null;
                this.interactiveTableWarnings = payload.warnings || [];

                // Apply adjustments locally
                this.config.workload_type = 'CUSTOM';
                this.config.custom_point_lookup_query = payload.custom_point_lookup_query || '';
                this.config.custom_range_scan_query = payload.custom_range_scan_query || '';
                this.config.custom_insert_query = payload.custom_insert_query || '';
                this.config.custom_update_query = payload.custom_update_query || '';
                if (shouldApplyMix) {
                    this.config.custom_point_lookup_pct = Number(payload.custom_point_lookup_pct || 0);
                    this.config.custom_range_scan_pct = Number(payload.custom_range_scan_pct || 0);
                    this.config.custom_insert_pct = Number(payload.custom_insert_pct || 0);
                    this.config.custom_update_pct = Number(payload.custom_update_pct || 0);
                }

                // Store column map + ai_workload metadata in config (will persist on save).
                if (payload.columns) {
                    this.config.columns = payload.columns;
                }
                // IMPORTANT: do not clobber prepared pool metadata (pool_id/columns). Only
                // store ai_workload hints if the template is not already prepared.
                if (payload.ai_workload) {
                    const existing = this.config.ai_workload;
                    const isPrepared = existing && typeof existing === 'object' && existing.pool_id;
                    if (!isPrepared) {
                        this.config.ai_workload = payload.ai_workload;
                    }
                }
                if (shouldApplyMix) {
                    this.syncMixPresetFromWeights();
                }

                // Toast only when unexpected (i.e., we had to disable an operation + redistribute mix).
                if (level === 'warning') {
                    const summary = payload.summary || 'SQL generated with issues.';
                    window.toast.warning(summary);
                }

                // Show Interactive Table warnings (each as a separate warning toast)
                if (this.interactiveTableWarnings && this.interactiveTableWarnings.length > 0) {
                    for (const warning of this.interactiveTableWarnings) {
                        window.toast.warning(warning, { duration: 10000 });
                    }
                }
            } catch (e) {
                window.toast.error('AI SQL adjustment failed: ' + (e?.message || e));
            } finally {
                this.aiSqlAdjustLoading = false;
            }
        },
        
        cancel() {
            window.location.href = '/templates';
        },
        
        async copyTemplate() {
            if (!this.loadedTemplate || this.copyTemplateLoading) return;
            
            this.copyTemplateLoading = true;
            const newTemplate = {
                ...this.loadedTemplate,
                template_name: this.loadedTemplate.template_name + ' (Copy)',
                template_id: undefined,
                created_at: undefined,
                updated_at: undefined,
                usage_count: 0
            };
            
            try {
                const response = await fetch('/api/templates/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newTemplate)
                });
                
                if (response.ok) {
                    const created = await response.json().catch(() => null);
                    if (created && created.template_id) {
                        window.toast.queueNext('success', 'Template copied successfully.');
                        // Open the newly created template in editable mode (your choice A).
                        window.location.href = `/configure?template_id=${encodeURIComponent(created.template_id)}`;
                        return;
                    }
                    window.toast.queueNext('success', 'Template copied successfully.');
                    window.location.href = '/templates';
                } else {
                    window.toast.error('Failed to copy template');
                }
            } catch (error) {
                console.error('Error copying template:', error);
                window.toast.error('Error copying template');
            } finally {
                this.copyTemplateLoading = false;
            }
        },
        
        async deleteTemplateWithResults() {
            if (!this.loadedTemplate) return;
            
            const confirmMsg = `Delete "${this.loadedTemplate.template_name}" and all ${this.loadedTemplate.usage_count} test results? This cannot be undone.`;
            const confirmed = await window.toast.confirm(confirmMsg, {
                confirmText: 'Delete',
                confirmVariant: 'danger',
                timeoutMs: 10_000,
            });
            if (!confirmed) {
                return;
            }
            
            this.deleteTemplateLoading = true;
            try {
                const response = await fetch(`/api/templates/${this.loadedTemplate.template_id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    window.toast.queueNext('success', 'Template and results deleted.');
                    window.location.href = '/templates';
                } else {
                    window.toast.error('Failed to delete template');
                }
            } catch (error) {
                console.error('Error deleting template:', error);
                window.toast.error('Error deleting template');
            } finally {
                this.deleteTemplateLoading = false;
            }
        },
        
        async resetConfig() {
            const confirmed = await window.toast.confirm('Reset all configuration?', {
                confirmText: 'Reset',
                confirmVariant: 'primary',
                timeoutMs: 10_000,
            });
            if (confirmed) {
                this.config = {
                    table_type: 'STANDARD',
                    database: '{{ default_database }}',
                    schema: 'PUBLIC',
                    table_name: '',
                    warehouse_name: '',
                    warehouse_size: 'MEDIUM',
                    multi_cluster: false,
                    min_clusters: 1,
                    max_clusters: 3,
                    scaling_policy: 'STANDARD',
                    duration: 300,
                    load_mode: 'CONCURRENCY',
                    target_qps: 100,
                    starting_threads: null,
                    max_thread_increase: 15,
                    scaling: {
                        mode: 'AUTO',
                        min_connections: 5,
                    },
                    guardrails: {
                        max_cpu_percent: 80,
                        max_memory_percent: 85,
                    },
                    concurrent_connections: 10,
                    start_concurrency: 5,
                    concurrency_increment: 10,
                    step_duration_seconds: 30,
                    qps_stability_pct: 40.0,
                    latency_stability_pct: 100.0,
                    max_error_rate_pct: 1.0,
                    workload_type: 'CUSTOM',
                    mix_preset: 'MIXED',
                    think_time: 0,
                    warmup: 30,
                    custom_point_lookup_query: 'Use AI Adjust or enter sql manually.',
                    custom_range_scan_query: 'Use AI Adjust or enter sql manually.',
                    custom_insert_query: 'Use AI Adjust or enter sql manually.',
                    custom_update_query: 'Use AI Adjust or enter sql manually.',
                    custom_point_lookup_pct: 25,
                    custom_range_scan_pct: 25,
                    custom_insert_pct: 35,
                    custom_update_pct: 15,
                    // Per-query-type targets (SLOs). Use -1 to disable a target.
                    target_point_lookup_p95_latency_ms: -1,
                    target_range_scan_p95_latency_ms: -1,
                    target_insert_p95_latency_ms: -1,
                    target_update_p95_latency_ms: -1,
                    target_point_lookup_p99_latency_ms: -1,
                    target_range_scan_p99_latency_ms: -1,
                    target_insert_p99_latency_ms: -1,
                    target_update_p99_latency_ms: -1,
                    target_point_lookup_error_rate_pct: -1,
                    target_range_scan_error_rate_pct: -1,
                    target_insert_error_rate_pct: -1,
                    target_update_error_rate_pct: -1,
                    test_name: '',
                    description: '',
                    save_as_template: false,
                    template_name: '',
                    template_description: ''
                };
                await this.loadCatalog();
            }
        }
    };
}
</script>
{% endblock %}
