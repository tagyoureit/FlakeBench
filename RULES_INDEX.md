<!--
╔══════════════════════════════════════════════════════════════════════════╗
║                           AUTO-GENERATED FILE                             ║
║                    DO NOT EDIT THIS FILE MANUALLY                         ║
╚══════════════════════════════════════════════════════════════════════════╝

Generated by: scripts/index_generator.py
Last updated: 2026-01-13 14:15:49

To regenerate this index:
  1. Make changes to rule files in rules/ directory
  2. Run: task index:generate
  3. Commit both rule files AND RULES_INDEX.md together

This index provides semantic discovery for AI agents.
-->

# Rules Index

This index provides semantic rule discovery for AI agents. All rules in `rules/` are production-ready and deployment-ready.

**Filename Convention (CRITICAL):**
- All rule references in this index use **bare filenames** (e.g., `000-global-core.md`)
- All rules are located in the `rules/` directory
- **Tool Call Translation:** When loading rules, prefix with `rules/`
- Example: `Depends: 000-global-core.md` in this index requires `read_file("rules/000-global-core.md")`

**How to Use This Index:**
- Browse by domain section (Core, Snowflake, Python, Shell, etc.)
- Search Keywords field for semantic discovery (technologies, patterns, use cases)
- Check Depends field for prerequisite rules


**For AI Agents:**
- This file is **READ-ONLY** for rule discovery purposes
- Use `grep`, `read_file`, or codebase_search to find relevant rules
- **Never modify** this file during task execution
- Regeneration happens automatically via `task index:generate`
- To suggest improvements, modify source rule files or `scripts/index_generator.py`


## Rule Loading Strategy

AI agents should follow this algorithm when loading rules:

### 1. Foundation (Always Load)
```
Load: 000-global-core.md
```

### 2. Domain Rules (Directory and File Extension Match)
Based on files mentioned in user request:

**Directory-based rules (check FIRST, before file extension):**
- `skills/` directory: Load `002g-claude-code-skills.md`
- `rules/` directory: Load `002-rule-governance.md`

**File extension rules:**
- `.py`, `.pyi`, `pyproject.toml`: Load `200-python-core.md`
- `.sql`: Load `100-snowflake-core.md`
- `.sh`, `.bash`, `.zsh`: Load `300-bash-scripting-core.md`
- `Dockerfile`, `docker-compose.yml`: Load `350-docker-best-practices.md`
- `.md` (outside `rules/` and `skills/`, e.g., README, CONTRIBUTING): Load `202-markup-config-validation.md`
- `.ts`, `.tsx`: Load `430-typescript-core.md`
- `.js`, `.jsx`: Load `420-javascript-core.md`
- `.go`: Load `600-golang-core.md`

### 3. Activity Rules (Keyword Match)
Use `grep -i "KEYWORD" RULES_INDEX.md` to search Keywords column:
- **skill**, SKILL.md, skill authoring: Consider `002g-claude-code-skills.md`
- **test**, pytest, coverage: Consider `206-python-pytest.md`
- **lint**, format, code quality: Consider `201-python-lint-format.md`
- **deploy**, CI/CD, automation: Consider `820-taskfile-automation.md`
- **streamlit**, dashboard: Consider `101-snowflake-streamlit-core.md`
- **docker**, container: Consider `350-docker-best-practices.md`
- **agent**, cortex agent: Consider `115-snowflake-cortex-agents-core.md`
- **semantic view**: Consider `106-snowflake-semantic-views-core.md`
- **README**, documentation: Consider `801-project-readme.md`

### 4. Check Dependencies
- For each rule to be loaded, read its **Depends On** column
- Load all prerequisite rules first (in dependency order)
- If rule lists multiple dependencies, load all of them

### 5. Token Budget Management
**Progressive Loading Strategy:**
- **Minimal**: Foundation + Domain = ~3,000-5,000 tokens (covers 70-80% of tasks)
- **Standard**: + 1-2 activity-specific rules = ~8,000-12,000 tokens
- **Complete**: + specialized rules = ~15,000-20,000 tokens

**Token Budget Check:**

**Warning Threshold:** At 15,000 tokens, begin deferring Low-tier rules and evaluate Medium-tier necessity.

**Example - At 17,000 tokens:**
```
Loaded (Critical/High):
- 000-global-core.md, 200-python-core.md, 206-python-pytest.md

Deferred (Medium/Low - available if needed):
- 204-python-docs-comments.md (not required for test execution)
```

If total exceeds 20,000 tokens, prioritize by ContextTier:
1. Critical (always load)
2. High (load if directly relevant)
3. Medium (defer unless task complexity requires)
4. Low (load only if explicitly needed)

**Token Budget Enforcement:**
- Agent self-regulates token budget (no external enforcement)
- At 15,000 tokens: Log warning, begin deferring Low/Medium tier rules
- At 20,000 tokens: STOP loading additional rules, proceed with loaded rules only

**Deferral Priority (when at warning threshold):**
1. Defer all Low tier rules first
2. Defer Medium tier rules not directly related to task keywords
3. Never defer Critical tier rules

**Declaration Format (when deferring):**
```markdown
## Rules Loaded
- rules/000-global-core.md (foundation)
- rules/200-python-core.md (file extension: .py)
- [Deferred: 204-python-docs-comments.md - Low tier, not required for task]
```

### 6. Declare Loaded Rules
After loading, list all rules in response:
```markdown
## Rules Loaded
- rules/000-global-core.md (foundation)
- rules/200-python-core.md (file extension: .py)
- rules/206-python-pytest.md (keyword: test)
```

**Example Workflow:**

User: "Write tests for my Streamlit dashboard"

**Rule Selection:**
- Extension `.py`: 200-python-core.md
- Keyword "test": 206-python-pytest.md
- Keyword "Streamlit": 101-snowflake-streamlit-core.md
- Dependency check: 101 requires 100-snowflake-core.md

**Token Budget:** 000 (3300) + 200 (1800) + 206 (3500) + 100 (1800) + 101 (3700) = 14,100 ✓

**Declaration:**
```markdown
## Rules Loaded
- rules/000-global-core.md (foundation)
- rules/200-python-core.md (file extension: .py)
- rules/100-snowflake-core.md (dependency of 101)
- rules/101-snowflake-streamlit-core.md (keyword: Streamlit)
- rules/206-python-pytest.md (keyword: test)
```


## Rule Catalog

### Core Foundation (000-series)

**`000-global-core.md`** - Foundational operating contract for all AI coding assistants, ensuring reliable, safe, and consistent workflows through mode-based operations, task confirmation protocols, and professional communication standards.
- Keywords: PLAN mode, ACT mode, workflow, safety, confirmation, validation, surgical edits, minimal changes, mode violations, prompt engineering, task list, read-only, authorization
- Depends: —

**`001-memory-bank.md`** - Universal principles for maintaining project context through structured memory bank documentation. Establishes patterns for context recovery across session resets, context preservation, aggressive pruning, and attention budget management. All write operations must be scoped to `memory-bank/` directory only.
- Keywords: memory bank, context, session recovery, project brief, active context, progress tracking, context rot, attention budget, compaction, context engineering, rapid recovery, failure recovery, staleness detection, archive policy, signal maximization
- Depends: `000-global-core.md`

**`002-rule-governance.md`** - Schema standards (v3.2) for AI coding rule files. Defines required sections, metadata fields, Contract structure, and validation requirements. All rules must comply with `schemas/rule-schema.yml` v3.2 specifications.
- Keywords: rule governance, schema, metadata requirements, validation, schema compliance, rule structure, semantic discovery, RULES_INDEX, descriptive headings
- Depends: `000-global-core.md`

**`002a-rule-creation.md`** - Step-by-step workflow for creating new rules from scratch. Covers rule numbering, naming conventions, metadata setup, v3.2 section structure, Contract with Markdown headers, and validation. For updating existing rules, see 002b-rule-update.md.
- Keywords: rule creation, workflow, step-by-step guide, naming conventions, metadata setup, v3.2 schema, validation, rule numbering, from scratch, new rule
- Depends: `002-rule-governance.md`, `000-global-core.md`

**`002b-rule-update.md`** - Workflow and best practices for updating and maintaining existing rule files. Covers semantic versioning (MAJOR/MINOR/PATCH), LastUpdated field management, common update scenarios, and validation requirements.
- Keywords: rule update, rule maintenance, versioning, RuleVersion, LastUpdated, semantic versioning, MAJOR, MINOR, PATCH, rule modification, keyword expansion, scope updates, metadata updates, CHANGELOG updates
- Depends: `002-rule-governance.md`, `000-global-core.md`

**`002c-rule-optimization.md`** - Guidelines for optimizing rule token budgets, sizing rules appropriately, and loading rules efficiently. Covers token budget tiers (Small: 1000-2000, Standard: 2000-3500, Large: 3500-5000+), progressive loading strategies, and performance optimization across different AI models for cost efficiency.
- Keywords: token budget, optimization, performance, rule sizing, progressive loading, context window, model limits, cost efficiency, caching, batch loading
- Depends: `002-rule-governance.md`, `000-global-core.md`

**`002d-advanced-rule-patterns.md`** - Advanced patterns for writing rules that balance specificity with flexibility. Focuses on system prompt altitude (the "Goldilocks Zone"), investigation-first protocols, anti-pattern structures, multi-session workflows, and parallel execution design.
- Keywords: system prompt altitude, investigation-first, anti-patterns, multi-session workflows, parallel execution, advanced patterns, heuristics, goldilocks zone, context management, state management
- Depends: `002-rule-governance.md`, `000-global-core.md`

**`002e-schema-validator-usage.md`** - Core guide for running `schema_validator.py` against v3.2 rules. Covers command usage, interpreting validation output, resolving common errors, and understanding severity levels.
- Keywords: schema validator, validation errors, error resolution, exit codes, command options, output parsing, error severity, CRITICAL errors, HIGH warnings, MEDIUM info
- Depends: `002-rule-governance.md`, `000-global-core.md`

**`002f-schema-validator-advanced.md`** - Advanced automation patterns for schema validation including programmatic output parsing, CI/CD integration, automated fix workflows, and batch validation strategies.
- Keywords: schema validator, CI/CD integration, automation workflow, JSON parsing, programmatic validation, pre-commit hooks, GitHub Actions, batch validation, error automation, validation scripts
- Depends: `002e-schema-validator-usage.md`, `002-rule-governance.md`, `000-global-core.md`

**`002g-agent-optimization.md`** - The PRIMARY design priority for all rules: **agent understanding and execution reliability**. All rules are instruction sets for autonomous AI agents, not reference documents for humans.
- Keywords: agent, LLM, optimization, format, token, efficiency, understanding, execution, comprehension, design, patterns, priority, agent-first
- Depends: `000-global-core.md`, `002-rule-governance.md`

**`002h-claude-code-skills.md`** - Best practices for authoring Claude Code skills in the `skills/` directory. Covers SKILL.md structure, YAML frontmatter, directory organization, progressive disclosure patterns, input/output contracts, workflow phases, trigger keywords, and testing strategies for reproducible, production-ready agent skills.
- Keywords: Claude Code, skills, SKILL.md, skill structure, progressive disclosure, workflows, trigger keywords, skill authoring, skill testing, skill validation, input contracts, output contracts, skill examples, YAML frontmatter, description writing, MCP tools, degrees of freedom, context window, third person, naming conventions
- Depends: `000-global-core.md`, `002-rule-governance.md`

**`003-context-engineering.md`** - Comprehensive context engineering practices that treat context as a finite resource with diminishing returns. Covers attention budgets (n² pairwise relationships), context rot, progressive disclosure, sub-agent patterns, agentic search vs RAG, compaction strategies, and long-horizon task management.
- Keywords: context engineering, attention budget, context rot, token efficiency, compaction, progressive disclosure, sub-agents, agentic search, system prompts, right altitude, long-horizon tasks, memory management, state tracking
- Depends: `000-global-core.md`

**`004-tool-design-for-agents.md`** - Comprehensive tool design practices that maximize agent effectiveness. Covers single responsibility, token-efficient outputs, LLM-friendly parameters, clear contracts, minimal tool overlap, self-contained design, robust error handling, and patterns that promote efficient agent behaviors.
- Keywords: tool design, agent tools, token efficiency, tool parameters, function calling, tool overlap, tool contracts, error handling, minimal tool set, self-contained tools, LLM-friendly parameters, single responsibility
- Depends: `000-global-core.md`, `003-context-engineering.md`


### Snowflake (100-series)

**`100-snowflake-core.md`** - Comprehensive foundational practices for all Snowflake development work, ensuring cost-effective, performant, and secure solutions through proper SQL authoring, object naming, security policies, and architectural patterns.
- Keywords: SQL, CTE, performance, cost optimization, query profile, warehouse, security, governance, stages, COPY INTO, streams, tasks, warehouse creation
- Depends: `000-global-core.md`

**`100f-snowflake-connection-errors.md`** - Systematic error classification for Snowflake connection errors using message-first analysis (never 1:1 error code mapping) to prevent misdiagnosis of network policy violations as authentication failures. Detection order: network policy indicators -> specific auth codes (390114, 390318, 390144) -> transient errors -> permissions -> generic 08001 fallback. Applies to snowflake-connector-python across Python scripts, CLI tools, REST APIs, Streamlit apps, and Snowpark applications.
- Keywords: connection errors, error classification, network policy, authentication, VPN, error codes, 08001, 390114, error handling, snowflake.connector, DatabaseError, message analysis, error detection
- Depends: `100-snowflake-core.md`

**`101-snowflake-streamlit-core.md`** - Foundational Streamlit application setup, navigation patterns, state management, deployment mode selection (Streamlit in Snowflake [SiS] vs SPCS), and theming configuration using config.toml as the primary styling method.
- Keywords: Streamlit, SPCS, SiS, navigation, multipage, session state, st.connection, config.toml, theming, deployment, pandas, null handling, session management, navigation performance, streamlit app, streamlit snowflake, build streamlit, create streamlit, multipage app, secrets management
- Depends: `100-snowflake-core.md`

**`101a-snowflake-streamlit-visualization.md`** - Router rule for Streamlit visualization library selection. Provides quick guidance on choosing between Plotly, PyDeck, and Altair, then delegates to specialized sub-rules for detailed patterns.
- Keywords: st.plotly_chart, st.pydeck_chart, st.altair_chart, dashboard, interactive charts, map visualization, chart types, visualization selection, streamlit plotting
- Depends: `101-snowflake-streamlit-core.md`

**`101b-snowflake-streamlit-performance.md`** - Comprehensive guidance for optimizing Streamlit application performance through caching strategies (@st.cache_data, @st.cache_resource), efficient data loading from Snowflake with column normalization, progress indicators (st.spinner, st.progress, fragments), and performance profiling targeting <2s load times. For detailed SQL error handling patterns, see 101e-snowflake-streamlit-sql-errors.md.
- Keywords: @st.cache_data, @st.cache_resource, st.fragment, NULL handling, slow streamlit, streamlit caching, optimize streamlit, fix slow queries, fragment batch processing, streamlit performance, app slow, loading data, caching pattern
- Depends: `101-snowflake-streamlit-core.md`, `103-snowflake-performance-tuning.md`

**`101c-snowflake-streamlit-security.md`** - Comprehensive security guidance for Streamlit applications including input validation with bounds checking, secrets management via st.secrets, SQL injection prevention with parameterized queries, authentication patterns for sensitive apps, file upload validation, error handling that doesn't expose credentials, and production deployment security with HTTPS and RBAC.
- Keywords: st.secrets, SQL injection, authentication, secure streamlit, protect app, credentials management, API keys, environment variables, secure deployment, input sanitization, RBAC streamlit, access control, security patterns
- Depends: `101-snowflake-streamlit-core.md`, `107-snowflake-security-governance.md`

**`101d-snowflake-streamlit-testing.md`** - Comprehensive testing and debugging guidance for Streamlit applications using AppTest patterns (Streamlit 1.28+), unit testing strategies with pytest for data functions, mocking external services with unittest.mock, cache behavior testing, edge case coverage (empty, NULL, invalid), and debugging workflows targeting >80% test coverage without hitting production data.
- Keywords: test Streamlit app, pytest, test framework, test patterns, app testing, UI testing, test automation, streamlit test suite, integration testing, test coverage, debug tests, test fixtures, testing strategies
- Depends: `101-snowflake-streamlit-core.md`, `206-python-pytest.md`

**`101e-snowflake-streamlit-sql-errors.md`** - Comprehensive SQL error handling patterns for Streamlit applications using SnowparkSQLException with error codes, query context display (table names, operations, filters), numbered queries for multiple query scenarios, user input validation, complex join debugging, empty result handling (st.warning vs st.error), and st.stop() cascade prevention.
- Keywords: SnowparkSQLException, error messages, Streamlit errors, Snowflake errors, debug SQL error, fix query error, SQL exception, error troubleshooting, query failed, database error, SQL debugging patterns, exception handling, error recovery, common SQL errors, streamlit error, app error, fix error, error handling
- Depends: `100-snowflake-core.md`, `101-snowflake-streamlit-core.md`, `101b-snowflake-streamlit-performance.md`

**`101f-snowflake-streamlit-spcs-errors.md`** - SPCS-specific deployment error scenarios and resolution steps for Streamlit applications running on Snowpark Container Services.
- Keywords: SPCS error, Docker build failure, container networking, image registry, service startup timeout, port binding, deployment error, container error, SPCS troubleshooting
- Depends: `101-snowflake-streamlit-core.md`

**`101g-snowflake-streamlit-fragments.md`** - Advanced Streamlit fragment patterns for real-time progress tracking, live polling, and automatic UI updates without full page reruns.
- Keywords: st.fragment, run_every, real-time progress, polling, live updates, fragment pattern, auto-refresh, streaming, monitoring dashboard
- Depends: `101-snowflake-streamlit-core.md`, `101b-snowflake-streamlit-performance.md`

**`101h-snowflake-streamlit-timeseries.md`** - Time-based aggregation and smoothing patterns for high-frequency data visualization in Streamlit applications.
- Keywords: time series smoothing, data aggregation, resample, SCADA data, high-frequency data, trend analysis, rolling average, EWMA, exponential smoothing
- Depends: `101a-snowflake-streamlit-visualization.md`

**`101i-snowflake-streamlit-viz-plotly.md`** - Deep patterns for Plotly visualization in Streamlit, including Plotly Express for rapid development, Graph Objects for custom visualizations, advanced features like animations, faceting, and subplots.
- Keywords: plotly, plotly express, graph objects, st.plotly_chart, interactive charts, scatter, line, bar, histogram, heatmap, box plot, violin, sunburst, treemap, animations, faceting, subplots
- Depends: `101a-snowflake-streamlit-visualization.md`

**`101j-snowflake-streamlit-viz-pydeck.md`** - PyDeck (deck.gl) visualization patterns for Streamlit, including 3D visualizations, hexbin aggregation, terrain rendering, and large-scale geospatial data. PyDeck excels where Plotly reaches limitations.
- Keywords: pydeck, st.pydeck_chart, deck.gl, 3D visualization, hexagon layer, scatterplot layer, geojson layer, arc layer, heatmap layer, terrain, point cloud, WebGL, geospatial
- Depends: `101a-snowflake-streamlit-visualization.md`

**`101k-snowflake-streamlit-viz-altair.md`** - Altair visualization patterns using the declarative grammar of graphics approach. Altair excels at statistical visualizations and linked multi-view displays with minimal code.
- Keywords: altair, vega-lite, st.altair_chart, declarative visualization, grammar of graphics, mark_point, mark_line, mark_bar, encoding, selection, interactive, layered charts
- Depends: `101a-snowflake-streamlit-visualization.md`

**`102-snowflake-sql-core.md`** - Essential SQL file authoring patterns for Snowflake: file headers, COPY INTO syntax, CREATE VIEW syntax, fully qualified object names, reserved character handling for CLI compatibility, and idempotent pattern foundations. This rule provides general patterns that apply to both demo and production SQL files.
- Keywords: SQL files, file headers, COPY INTO, FILE_FORMAT, CREATE VIEW, fully qualified names, idempotent, reserved characters, CLI compatibility, ON_ERROR
- Depends: `100-snowflake-core.md`

**`102a-snowflake-sql-automation.md`** - Guide creation of parameterized SQL templates using <%VARIABLE%> syntax for automated Snowflake deployments in production environments. NEVER use CREATE OR REPLACE TABLE (data loss risk), instead use CREATE TABLE IF NOT EXISTS and MERGE for idempotent upserts. Supports CI/CD pipelines with environment-specific secrets, multi-environment workflows (dev/test/prod), infrastructure-as-code patterns, documented parameters in headers, and safe-to-rerun operations. Optimized for DevOps engineers, data engineers, and automated deployment systems.
- Keywords: idempotent, MERGE, operations, multi-environment, infrastructure as code, Snowflake variables, production-safe, upsert, SQL automation, deployment scripts, SQL pipeline, config management, environment variables
- Depends: `102-snowflake-sql-core.md`

**`103-snowflake-performance-tuning.md`** - Systematic approaches for profiling, optimizing, and fine-tuning Snowflake queries and warehouse usage to achieve optimal performance while managing costs effectively.
- Keywords: search optimization, pruning, spillage, SQL optimization, Snowflake, partition pruning, QUERY_HISTORY, optimize query, fix slow query, query bottleneck, warehouse performance, micro-partitions, clustering, performance analysis
- Depends: `100-snowflake-core.md`

**`104-snowflake-streams-tasks.md`** - Patterns for building robust, incremental data pipelines using Snowflake Streams and Tasks, covering change data capture, scheduling, idempotency, and monitoring for reliable data processing workflows.
- Keywords: scheduled tasks, pipeline automation, MERGE patterns, SQL, Snowflake, task DAG, AFTER dependencies, Task History, create stream, create task, debug stream, task troubleshooting, stream consumption, task execution error, stream lag
- Depends: `100-snowflake-core.md`

**`105-snowflake-cost-governance.md`** - Comprehensive cost management and optimization strategies for Snowflake environments, including resource monitoring, warehouse right-sizing, and governance policies to control and predict cloud data warehouse spending.
- Keywords: budget alerts, spend tracking, Snowflake, SQL, CREDIT_QUOTA, WAREHOUSE_METERING_HISTORY, object tagging, monitor credits, warehouse spending, cost alerts, credit limits, budget management, resource monitor, tag enforcement
- Depends: `100-snowflake-core.md`

**`106-snowflake-semantic-views-core.md`** - Authoritative guidance for creating Snowflake Native Semantic Views using the `CREATE SEMANTIC VIEW` DDL syntax. Focuses on DDL structure, component definitions, anti-patterns, and comprehensive validation rules to prevent errors during semantic view creation.
- Keywords: TABLES, RELATIONSHIPS, PRIMARY KEY, validation rules, semantic view error, create semantic view, debug semantic view, SQL, verified queries, VQR, YAML semantic model, NLQ, mapping syntax, granularity rules
- Depends: `100-snowflake-core.md`

**`106a-snowflake-semantic-views-advanced.md`** - Advanced patterns for semantic views including anti-patterns to avoid, comprehensive validation rules, quality checks, and compliance requirements.
- Keywords: compliance, common mistakes, validation rules, semantic model quality, semantic view pitfalls, debug semantic view, fix semantic view errors, validation failures, relationship errors, mapping errors, quality assurance, semantic view testing, validation patterns
- Depends: `100-snowflake-core.md`, `106-snowflake-semantic-views-core.md`

**`106b-snowflake-semantic-views-querying.md`** - Comprehensive guidance for querying Snowflake Semantic Views using the `SEMANTIC_VIEW()` function and validating semantic view implementations through systematic testing. Covers query syntax, dimension compatibility, window function metrics, WHERE clause usage, and performance optimization.
- Keywords: window functions, dimension compatibility, testing, validation, TPC-DS, performance optimization, aliases, granularity, query semantic view, semantic view results, query patterns, result processing, SEMANTIC_VIEW function, query errors, dimension filters
- Depends: `106-snowflake-semantic-views-core.md`

**`106c-snowflake-semantic-views-integration.md`** - Comprehensive guidance for integrating Snowflake Semantic Views with Cortex Analyst and Cortex Agent, applying governance and security controls, and following production-ready development workflows including the Semantic View Generator tool.
- Keywords: RBAC, masking policy, row access policy, Generator workflow, iterative development, synonyms, natural language queries, cortex analyst, agent integration, semantic view security, analyst troubleshooting, fix analyst, debug analyst
- Depends: `106-snowflake-semantic-views-core.md`, `106b-snowflake-semantic-views-querying.md`

**`107-snowflake-security-governance.md`** - Comprehensive data security and access control practices using Snowflake's governance features, including RBAC, data masking, row-level security, and object tagging for enterprise-grade data protection.
- Keywords: roles, grants, secure views, security policies, access control, data security, policy troubleshooting, grant management, Data Metric Functions, DMF, least privilege, create masking policy, tagging, SQL
- Depends: `100-snowflake-core.md`

**`108-snowflake-data-loading.md`** - Comprehensive best practices for efficiently staging and bulk loading data into Snowflake using Stages and COPY INTO commands, optimizing for performance, reliability, and cost-effectiveness in batch loading scenarios.
- Keywords: bulk loading, ON_ERROR, FILE_FORMAT, load data, external stage, internal stage, data ingestion, file upload, COPY error, loading patterns, stage files, PUT command, GET command
- Depends: `100-snowflake-core.md`

**`109-snowflake-notebooks.md`** - Best practices for building reproducible, secure, and maintainable Jupyter Notebooks within the Snowflake environment, ensuring deterministic execution, proper state management, and seamless transition to production code.
- Keywords: ML, reproducible notebooks, nbqa, notebook linting, code quality, Python, create notebook, debug notebook, notebook execution, notebook testing, notebook deployment, kernel management, cell execution
- Depends: `100-snowflake-core.md`, `201-python-lint-format.md`

**`109a-snowflake-notebooks-tutorials.md`** - Comprehensive patterns for designing educational Snowflake notebooks that effectively teach concepts through clear learning objectives, structured content, anti-pattern examples, validation checkpoints, and progressive complexity management.
- Keywords: checkpoints, learning objectives, pedagogical design, educational content, progressive learning, Snowflake notebooks, teaching point callouts, validation gates, tutorial structure, learning design, educational notebooks, teaching methodology, notebook education
- Depends: `109-snowflake-notebooks.md`, `920-data-science-analytics.md`

**`109b-snowflake-app-deployment-core.md`** - Core deployment automation patterns for Snowflake applications (Notebooks, Streamlit apps, UDFs, and other staged applications), ensuring reliable, deterministic deployments through proper stage file management and object lifecycle control.
- Keywords: CREATE NOTEBOOK, stages, deployment automation, SiS, deploy app, deployment pipeline, app publishing, deployment patterns, deploy to snowflake, stage deployment, production deployment, app versioning, automated deployment
- Depends: `100-snowflake-core.md`, `109-snowflake-notebooks.md`, `101-snowflake-streamlit-core.md`, `820-taskfile-automation.md`

**`109c-snowflake-app-deployment-troubleshooting.md`** - Comprehensive troubleshooting guidance and anti-pattern identification for Snowflake application deployments, focusing on common errors, diagnostic commands, and proven solutions for Streamlit in Snowflake (SiS) TypeError issues and notebook caching problems.
- Keywords: Snowflake deployment troubleshooting, Streamlit debugging, SiS TypeError, notebook deployment issues, deployment errors, stage file debugging, AUTO_COMPRESS debugging, ROOT_LOCATION errors, deployment anti-patterns, diagnostic commands, deployment validation, cache issues
- Depends: `100-snowflake-core.md`, `109-snowflake-notebooks.md`, `101-snowflake-streamlit-core.md`, `109b-snowflake-app-deployment-core.md`

**`110-snowflake-model-registry.md`** - Comprehensive best practices for using Snowflake Model Registry to manage machine learning models, ensuring secure, performant, and governable ML operations through proper lifecycle management, access control, versioning strategies, and cost optimization.
- Keywords: model governance, model lifecycle, model logging, model inference, RBAC, model privileges, register model, log model, model management, ML registry, model tracking, model metadata, deploy model, model lineage
- Depends: `100-snowflake-core.md`

**`111-snowflake-observability-core.md`** - Foundational observability practices for Snowflake environments through telemetry configuration and event table management, enabling effective monitoring, troubleshooting, and performance optimization.
- Keywords: LOG_LEVEL, TRACE_LEVEL, METRIC_LEVEL, SHOW PARAMETERS, OpenTelemetry, System Views vs Telemetry, monitoring, logging, tracing, debug observability, event table queries, observability patterns, configure telemetry
- Depends: `100-snowflake-core.md`

**`111a-snowflake-observability-logging.md`** - Comprehensive logging best practices for Snowflake handler code, covering standard library integration, strategic log level usage, conditional logging patterns, and volume control strategies to optimize observability while managing costs.
- Keywords: DEBUG, INFO, WARN, ERROR, FATAL, conditional logging, sampling, tight loop logging, standard logging libraries, log volume control, cost management, log configuration, log handlers
- Depends: `100-snowflake-core.md`, `111-snowflake-observability-core.md`

**`111b-snowflake-observability-tracing.md`** - Distributed tracing and metrics collection patterns for Snowflake handlers using `snowflake-telemetry-python` package. Covers span creation, nested tracing hierarchies, performance analysis, bottleneck identification, resource monitoring, and trace event limits (128 events/span maximum).
- Keywords: span attributes, trace_id, performance analysis, metrics collection, cpu_usage, memory_usage, telemetry.create_span, OpenTelemetry, nested spans, tracing patterns, span creation, trace analysis, distributed traces
- Depends: `100-snowflake-core.md`, `111-snowflake-observability-core.md`

**`111c-snowflake-observability-monitoring.md`** - Monitoring, analysis, and cost management for Snowflake observability. Covers Snowsight monitoring interfaces (Traces & Logs, Query History, Copy History, Task History), AI observability patterns for Cortex AI token tracking, troubleshooting workflows, System Views vs Event Tables selection, and telemetry cost optimization.
- Keywords: Copy History, Task History, Dynamic Tables, cost management, AI observability, Cortex AI, token tracking, troubleshooting, performance analysis, monitor queries, monitoring dashboard, observability UI, query monitoring, telemetry volume, SQL
- Depends: `100-snowflake-core.md`, `111-snowflake-observability-core.md`

**`112-snowflake-snowcli.md`** - Clear, reproducible guidance for installing, invoking, and automating Snowflake CLI (SnowCLI) with hermetic, pinned execution. Covers uvx usage, Taskfile automation, profile/env var configuration, CI/CD patterns, version pinning, and secure credential management.
- Keywords: snow CLI, SnowCLI, Snowflake CLI, snowflake-cli, uvx, Taskfile, task automation, deployment automation, snowflake.yml, profiles, CI/CD, JSON output, authentication, stage copy
- Depends: `100-snowflake-core.md`

**`113-snowflake-feature-store.md`** - Comprehensive best practices for Snowflake Feature Store: creating, maintaining, and serving ML features with consistency and reusability. Covers feature engineering, entity modeling, feature views (Snowflake-managed and external), point-in-time correctness with ASOF JOIN, ML dataset creation, and Model Registry integration for production-ready pipelines.
- Keywords: feature views, entity modeling, ML pipeline, ASOF JOIN, point-in-time correctness, Dynamic Tables, feature versioning, create features, feature catalog, feature pipeline, feature discovery, feature registry, feature lineage
- Depends: `100-snowflake-core.md`, `110-snowflake-model-registry.md`

**`114-snowflake-cortex-aisql.md`** - Pragmatic, production-focused patterns for using Snowflake Cortex AISQL functions for classification, extraction, summarization, translation, embeddings, transcriptions, document parsing, and aggregation—optimized for cost, throughput, security, and governance.
- Keywords: Cortex AISQL, AI_COMPLETE, AI_CLASSIFY, AI_EXTRACT, AI_SENTIMENT, AI_SUMMARIZE, embeddings, LLM functions, batching, token costs, text generation, classification, sentiment analysis, summarization, AI function error
- Depends: `100-snowflake-core.md`, `105-snowflake-cost-governance.md`

**`115-snowflake-cortex-agents-core.md`** - Comprehensive patterns to design, configure, secure, and operate Cortex Agents including agent archetypes, tool configurations, planning instructions, testing strategies, RBAC, observability, and quality evaluation, optimized for reliability and cost.
- Keywords: multi-tool agents, planning instructions, testing, troubleshooting, semantic views, create agent, debug agent, agent not working, tool execution failed, agent error, fix agent, agent performance, agent tool integration, cortex agent configuration, UnboundedExecution
- Depends: `100-snowflake-core.md`, `105-snowflake-cost-governance.md`, `106-snowflake-semantic-views-core.md`, `111-snowflake-observability-core.md`

**`115a-snowflake-cortex-agents-instructions.md`** - Comprehensive patterns for writing planning instructions (tool orchestration logic) and response instructions (output formatting and flagging logic) for Cortex Agents.
- Keywords: Cortex Agents, planning instructions, response instructions, tool orchestration, flagging logic, agent prompts, multi-tool orchestration, tool selection, agent prompting, instruction patterns, agent planning
- Depends: `100-snowflake-core.md`, `115-snowflake-cortex-agents-core.md`

**`115b-snowflake-cortex-agents-operations.md`** - Comprehensive operational patterns for Cortex Agents including testing strategies, RBAC configuration, observability, cost management, and error troubleshooting.
- Keywords: observability, evaluation, cost management, error troubleshooting, agent security, test agent, agent permissions, agent monitoring, agent evaluation, agent costs, debug agent, agent logs, agent trace, agent security policies
- Depends: `100-snowflake-core.md`, `115-snowflake-cortex-agents-core.md`, `111-snowflake-observability-core.md`

**`116-snowflake-cortex-search.md`** - Reliable patterns for building and querying Cortex Search indices, including data preparation, embedding hygiene, metadata filters, hybrid retrieval, agent tool configuration, and cost/latency considerations.
- Keywords: embeddings, search index, RAG, agent tools, retrieval, troubleshooting, AI_EMBED, create search service, search service error, document retrieval, search index creation, hybrid search, search service debug, vector similarity
- Depends: `100-snowflake-core.md`, `105-snowflake-cost-governance.md`, `111-snowflake-observability-core.md`, `114-snowflake-cortex-aisql.md`

**`117-snowflake-mcp-server.md`** - Authoritative, tool-agnostic guidance for using Snowflake's Snowflake-managed MCP server to expose governed Snowflake capabilities (Cortex Analyst/Search/Agents, SQL execution, and custom tools) to MCP-compatible clients.
- Keywords: MCP, Model Context Protocol, Snowflake-managed MCP server, CREATE MCP SERVER, SYSTEM_EXECUTE_SQL, CORTEX_ANALYST_MESSAGE, CORTEX_SEARCH_SERVICE_QUERY, CORTEX_AGENT_RUN, tools/list, tools/call, initialize, OAuth, SECURITY INTEGRATION, RBAC, PAT
- Depends: `100-snowflake-core.md`, `107-snowflake-security-governance.md`, `112-snowflake-snowcli.md`

**`118-snowflake-cortex-rest-api.md`** - Production patterns for Cortex REST API usage for interactive/low-latency workloads: authentication, Complete/Embed/Agents endpoints, retries, idempotency, streaming, cost controls, and observability.
- Keywords: idempotency, rate limits, Complete endpoint, Embed endpoint, exponential backoff, REST API, Cortex API, authentication tokens, PAT, OAuth, JWT, SSE, token verification, response format
- Depends: `100-snowflake-core.md`, `105-snowflake-cost-governance.md`, `111-snowflake-observability-core.md`

**`119-snowflake-warehouse-management.md`** - Comprehensive best practices for creating, configuring, and managing Snowflake virtual warehouses, including proper selection of warehouse types (CPU/GPU/High-Memory), mandatory GEN 2 preference, sizing strategies, auto-suspend configuration, tagging standards, and cost governance integration.
- Keywords: high-memory warehouse, warehouse tagging, auto-suspend, auto-resume, GEN 2, Snowpark-Optimized, warehouse edition, resource monitors, create warehouse, warehouse configuration, warehouse types, warehouse cost, size warehouse
- Depends: `100-snowflake-core.md`, `103-snowflake-performance-tuning.md`, `105-snowflake-cost-governance.md`

**`120-snowflake-spcs.md`** - Comprehensive guidance for deploying, managing, and optimizing containerized applications using Snowflake Snowpark Container Services (SPCS). Covers architecture patterns, compute pools, security, performance optimization, monitoring, logging, troubleshooting, and operational best practices for containerized workloads and microservices.
- Keywords: service deployment, compute pools, OCI images, image registry, health checks, GPU workloads, create service, compute pool, container deployment, service spec, container troubleshooting, SPCS error, service logs
- Depends: `100-snowflake-core.md`

**`121-snowflake-snowpipe.md`** - Comprehensive best practices for continuous file-based data ingestion using Snowflake Snowpipe (serverless, event-driven). Covers architecture selection (auto-ingest vs REST API), file sizing optimization, cloud event configuration, security, monitoring, cost management, and troubleshooting for file-based ingestion patterns.
- Keywords: snowpipe, auto-ingest, REST API, file-based ingestion, event notifications, COPY INTO, create pipe, data ingestion, pipe errors, pipe management, micro-batching, serverless ingestion
- Depends: `100-snowflake-core.md`, `108-snowflake-data-loading.md`, `104-snowflake-streams-tasks.md`

**`121a-snowflake-snowpipe-streaming.md`** - SDK-based continuous data ingestion using Snowpipe Streaming for low-latency, row-level writes directly to Snowflake tables. Covers architecture selection (high-performance vs classic), SDK usage (Java, Python, .NET), channel management, offset tracking, schema evolution, monitoring, and troubleshooting for sub-second latency requirements. This is a **separate, complementary approach** to file-based Snowpipe (121), not an extension of it.
- Keywords: snowpipe streaming, streaming SDK, high-performance streaming, classic streaming, channel management, row-level ingestion, low-latency ingestion, offset tracking, schema evolution, streaming API, Java SDK, Python SDK, .NET SDK, sub-second latency, real-time ingestion, streaming channels
- Depends: `100-snowflake-core.md`, `108-snowflake-data-loading.md`

**`121b-snowflake-snowpipe-monitoring.md`** - Monitoring, cost tracking, and performance analysis for both file-based Snowpipe and Snowpipe Streaming. Covers load history queries, channel status monitoring, credit usage tracking, cost optimization strategies, and alerting patterns for production Snowpipe deployments.
- Keywords: snowpipe monitoring, cost management, load history, pipe usage, streaming monitoring, channel status, credits tracking, performance metrics, cost optimization, observability, metering history, monitoring queries
- Depends: `100-snowflake-core.md`, `121-snowflake-snowpipe.md`, `121a-snowflake-snowpipe-streaming.md`

**`121c-snowflake-snowpipe-troubleshooting.md`** - Troubleshooting and debugging patterns for both file-based Snowpipe and Snowpipe Streaming. Covers common issues, error resolution strategies, debugging checklists, and diagnostic queries for production Snowpipe deployments.
- Keywords: snowpipe troubleshooting, debugging, error resolution, pipe errors, streaming errors, connection failures, schema errors, offset tracking, latency issues, duplicate data, authentication errors, channel errors
- Depends: `100-snowflake-core.md`, `121-snowflake-snowpipe.md`, `121a-snowflake-snowpipe-streaming.md`

**`122-snowflake-dynamic-tables.md`** - Comprehensive best practices for Snowflake Dynamic Tables for efficient, maintainable, and cost-effective materialized query results that automatically refresh based on changes to base tables. Covers refresh modes (INCREMENTAL vs FULL), lag configuration (TARGET_LAG, DOWNSTREAM), warehouse sizing, modular pipeline architecture, monitoring, troubleshooting, and cost optimization for automated materialized views and data pipeline orchestration.
- Keywords: automatic pipelines, DOWNSTREAM, FULL, warehouse sizing, data freshness, create dynamic table, dynamic table lag, refresh frequency, dynamic table error, materialized view alternative, pipeline automation, lag configuration, refresh strategies
- Depends: `100-snowflake-core.md`, `104-snowflake-streams-tasks.md`, `119-snowflake-warehouse-management.md`

**`123-snowflake-object-tagging.md`** - Comprehensive best practices for Snowflake object tagging to enable effective data governance, cost attribution, security classification, and resource monitoring through consistent metadata management. Covers tag taxonomy design, tag hierarchy, inheritance patterns, tag-based policies (masking, row access), cost attribution, tag lineage tracking, and governance enforcement across all supported Snowflake objects.
- Keywords: cost attribution, resource tagging, governance tags, masking policies, row access policies, tag lineage, create tags, apply tags, tag strategy, tag policies, tag compliance, tag hierarchy, tag discovery, tag management
- Depends: `100-snowflake-core.md`, `105-snowflake-cost-governance.md`, `107-snowflake-security-governance.md`

**`124-snowflake-data-quality-core.md`** - Comprehensive best practices for Snowflake Data Quality Monitoring using Data Metric Functions (DMFs), data profiling, expectations, and automated quality checks. Covers system DMFs, custom DMF creation, data profiling workflows, expectation definitions, scheduling strategies, event table monitoring, alerting, remediation workflows, and cost optimization to ensure data reliability, integrity, and compliance throughout the data lifecycle.
- Keywords: data profiling, expectations, quality checks, data validation, NULL detection, uniqueness validation, freshness monitoring, anomaly detection, automated monitoring, event tables, create DMF, quality monitoring, data expectations, quality rules
- Depends: `100-snowflake-core.md`, `105-snowflake-cost-governance.md`, `107-snowflake-security-governance.md`, `930-data-governance-quality.md`

**`124a-snowflake-data-quality-custom.md`** - Patterns for creating custom Data Metric Functions (DMFs) and expectations to implement business-specific quality rules and validation logic beyond system DMFs. Covers custom DMF creation, business rule validation, expectation thresholds, testing strategies, and documentation requirements.
- Keywords: quality assertions, custom metrics, validation functions, create custom DMF, custom quality checks, business rule validation, custom expectations, quality functions, UDF for quality, validation logic, custom quality metrics, quality rules, custom validation
- Depends: `100-snowflake-core.md`, `124-snowflake-data-quality-core.md`

**`124b-snowflake-data-quality-operations.md`** - Operational patterns for Data Quality Monitoring including DMF scheduling, event table analysis, alerting, remediation workflows, and RBAC configuration. Covers automated monitoring, quality event tables, alerting strategies, remediation patterns, and privilege requirements.
- Keywords: remediation, RBAC, privilege requirements, automated monitoring, quality alerts, schedule DMF, quality event tables, quality alerting, DMF results, quality workflows, DMF RBAC, quality notifications, remediation workflows
- Depends: `100-snowflake-core.md`, `124-snowflake-data-quality-core.md`, `111-snowflake-observability-core.md`

**`125-snowflake-role-introspection.md`** - Patterns for programmatically inspecting Snowflake roles and grants, handling both account-scoped roles and database roles to avoid SQL compilation errors when automating RBAC audits and permission checks. Covers role type detection, syntax differences, error handling (000906), and Python automation patterns.
- Keywords: account roles, database roles, SHOW GRANTS, role introspection, RBAC, Python automation, error 000906, too many qualifiers, grants inspection, programmatic RBAC
- Depends: `000-global-core.md`, `100-snowflake-core.md`


### Other

**`130-snowflake-demo-sql.md`** - SQL file patterns specifically for Snowflake demos, workshops, and customer learning environments. Covers schema-based file naming (`<schema>_<operation>.sql`), per-schema isolation with independent setup/teardown files, progress indicators (`SELECT '[PASS]'`), inline educational comments, and demo-safe idempotent patterns (`CREATE OR REPLACE TABLE`). Prioritizes ease of use, readability, and educational value over automation complexity.
- Keywords: demo SQL, workshop, teardown, progress indicators, rerunnable demos, CREATE OR REPLACE, educational SQL, demo patterns, setup scripts, customer learning, per-schema isolation, inline documentation
- Depends: `102-snowflake-sql-core.md`

**`131-snowflake-demo-creation.md`** - Directives for creating realistic, deterministic, and effective demo applications. Covers data generation, narrative design, and visual clarity to deliver compelling demonstrations that showcase product capabilities.
- Keywords: Demo creation, synthetic data, realistic demos, data generation, demo applications, narrative design, reproducible data, progressive disclosure, Streamlit, data visualization
- Depends: `130-snowflake-demo-sql.md`

**`132-snowflake-demo-modeling.md`** - Comprehensive data generation and modeling standards ensuring intuitive, analytics-friendly data for Business Analysts, Executive Users, Data Scientists, and Data Engineers. Covers naming conventions, relationship patterns, dimensional modeling (Kimball methodology), view taxonomy, and backward compatibility strategies.
- Keywords: Data modeling, naming conventions, Kimball, dimensional modeling, fact tables, dimension tables, foreign keys, view taxonomy, Business Analyst, data generation, backward compatibility, entity IDs, temporal columns, surrogate keys, SCD Type 2
- Depends: `130-snowflake-demo-sql.md`, `131-snowflake-demo-creation.md`

**`501-frontend-browser-globals-collisions.md`** - HTMX-driven UIs and server-rendered apps that embed JavaScript/Alpine helpers (<50 lines) in templates (including inline `<script>` blocks).
- Keywords: browser globals, javascript globals, window.history, HTMX history, Alpine.js, name collisions, reserved identifiers, implicit globals, historyRestore, hx-push-url, popstate, best practices, anti-patterns
- Depends: `500-frontend-htmx-core.md`

**`950-create-dbt-semantic-view.md`** - Creating Snowflake semantic views through dbt using the `dbt_semantic_view` package for analytics and Cortex Agent integration
- Keywords: dbt, semantic view, Snowflake, dbt_semantic_view, materialization, Cortex Analyst, YAML, semantic model, dbt models, analytics, business intelligence, data modeling
- Depends: `200-python-core.md`


### Python (200-series)

**`200-python-core.md`** - Foundational Python development practices using modern tooling (uv, Ruff, pytest, ty) to ensure consistent, reliable, and performant codebases with proper dependency management, linting, formatting, type checking, and project structure.
- Keywords: Python, uv, Ruff, pyproject.toml, dependency management, virtual environments, pytest, validation, uv run, uvx, ty, type checking, mypy, type hints
- Depends: `000-global-core.md`

**`201-python-lint-format.md`** - Authoritative Python code quality standards using Ruff as the primary tool for linting and formatting. Covers Ruff command patterns (`uvx ruff check`, `uvx ruff format`), pyproject.toml configuration, pydocstyle rules, pre-commit integration, and validation requirements. Includes tool isolation strategies and fallback approaches for environments without uv.
- Keywords: Ruff, linting, formatting, code quality, style checking, uvx ruff, lint errors, ruff check, ruff format, pyproject.toml configuration
- Depends: `200-python-core.md`

**`202-markup-config-validation.md`** - Safe markup and configuration file practices to prevent parsing errors and maintain consistency across YAML, TOML, environment files, and Markdown documentation. Covers YAML syntax safety, quoting rules, indentation standards, shell command safety, Taskfile patterns, TOML validation, Markdown linting with pymarkdownlnt, and security considerations for configuration files.
- Keywords: YAML, configuration files, YAML syntax, parsing errors, indentation, anchors, aliases, Markdown, markdown linting, pymarkdownlnt, markup validation, TOML, environment files
- Depends: —

**`203-python-project-setup.md`** - Essential Python project setup and packaging guidance covering package structure, pyproject.toml configuration, dependency management, and build error prevention. Includes __init__.py requirements, hatchling build system configuration, uv-based dependency management, virtual environment setup, and modern packaging patterns (src layout, optional dependencies, entry points).
- Keywords: Python packaging, project structure, setup.py, pyproject.toml, dependencies, package distribution, __init__.py, hatchling, uv, src layout
- Depends: `200-python-core.md`

**`204-python-docs-comments.md`** - Clear, enforceable standards for Python documentation (project docs), source code comments, and docstrings, aligned with PEP 257, PEP 8, and modern tooling (Ruff pydocstyle, Sphinx Napoleon). Covers Google and NumPy docstring styles, semantic depth requirements, side effects documentation, preconditions, performance considerations, thread safety, and enforcement patterns.
- Keywords: Python docstrings, documentation, comments, pydocstyle, Ruff DOC rules, API documentation, Google style, NumPy style, PEP 257, code quality, semantic depth, side effects, preconditions, performance, thread safety
- Depends: `200-python-core.md`, `201-python-lint-format.md`

**`205-python-classes.md`** - Practical, modern guidelines for when and how to use classes in Python, emphasizing composition over inheritance, type safety, encapsulation, and pythonic idioms. Covers dataclasses, properties, protocols, ABCs, resource management, and class design patterns that produce readable, maintainable, and testable code.
- Keywords: Python classes, OOP, inheritance, dataclasses, @property, class design, encapsulation, composition, Protocol, ABC, type hints
- Depends: `200-python-core.md`, `201-python-lint-format.md`, `204-python-docs-comments.md`

**`206-python-pytest.md`** - Pragmatic, industry-standard testing practices with pytest to produce fast, reliable, maintainable tests aligned with modern Python tooling conventions.
- Keywords: pytest, testing, fixtures, parametrization, test isolation, mocking, test organization, coverage, AAA pattern, test markers, uv run pytest
- Depends: `200-python-core.md`, `201-python-lint-format.md`, `203-python-project-setup.md`

**`207-python-logging.md`** - Best practices for Python logging in applications with dual output requirements (CLI and web UI), covering hierarchical logger names, handler configuration, Rich console integration, SSE/WebSocket streaming, structured logging, operation IDs, thread safety, and avoiding duplicate logs.
- Keywords: logging, Python logging, logger, handlers, formatters, log levels, WebLogHandler, Rich console, SSE streaming, structured logging, operation ID, thread safety, log hierarchy, log propagation
- Depends: `200-python-core.md`

**`210-python-fastapi-core.md`** - Comprehensive FastAPI development best practices for modern web API development. Covers application architecture (factory pattern, APIRouter), async programming patterns, request/response handling with Pydantic, error management, and cross-thread communication for building maintainable, performant web APIs.
- Keywords: FastAPI, async, REST API, Pydantic, dependency injection, routing, request validation, response models, APIRouter, uvicorn, async def, application factory
- Depends: `200-python-core.md`

**`210a-python-fastapi-security.md`** - Comprehensive security practices for FastAPI applications. Covers authentication (OAuth2, JWT), authorization (RBAC), password hashing (bcrypt), CORS configuration, security middleware, input validation, and production security hardening to protect APIs and user data.
- Keywords: FastAPI security, authentication, OAuth2, JWT, CORS, middleware, API keys, security best practices, bcrypt, HTTPBearer, role-based access control, RBAC
- Depends: `210-python-fastapi-core.md`

**`210b-python-fastapi-testing.md`** - Comprehensive testing strategies for FastAPI applications. Covers TestClient usage, pytest-asyncio for async tests, test database fixtures, dependency overrides, AAA pattern, mocking external dependencies, and integration testing patterns to ensure reliability and maintainability.
- Keywords: FastAPI testing, TestClient, pytest-asyncio, API tests, integration testing, mocking, test fixtures, AAA pattern, async testing, Python
- Depends: `210-python-fastapi-core.md`

**`210c-python-fastapi-deployment.md`** - Establish production deployment patterns and API documentation practices for FastAPI applications using Docker, ASGI servers, and OpenAPI customization.
- Keywords: FastAPI deployment, Uvicorn, Gunicorn, ASGI, Docker, production deployment, health checks, multi-stage build, OpenAPI, API documentation
- Depends: `210-python-fastapi-core.md`

**`210d-python-fastapi-monitoring.md`** - Establish monitoring, logging, and performance optimization patterns for FastAPI applications including health checks, structured logging, caching, and observability.
- Keywords: FastAPI monitoring, health checks, logging, metrics, caching, Redis, observability, structured logging, health endpoints, correlation IDs
- Depends: `210-python-fastapi-core.md`

**`220-python-typer-cli.md`** - Provide comprehensive guidance for building robust, user-friendly command-line applications using Typer, covering project setup, argument handling, testing strategies, and deployment patterns for maintainable CLI tools.
- Keywords: Typer, CLI development, command-line interface, click, argument parsing, CLI testing, typer.Argument, typer.Option, CliRunner, rich console
- Depends: `200-python-core.md`

**`221-python-htmx-core.md`** - Foundational HTMX patterns for Python web applications, covering request/response lifecycle, HTTP header management, security considerations, and hypermedia-driven architecture principles for building interactive web applications without JavaScript frameworks.
- Keywords: htmx, hypermedia, hateoas, hx-request, hx-trigger, partial rendering, sse, websockets, csrf, xss, http headers, swap strategies, oob swaps, response patterns
- Depends: `200-python-core.md`

**`221a-python-htmx-templates.md`** - Jinja2 template organization patterns for HTMX applications, covering partial rendering, fragment composition, conditional template logic, and reusable component strategies for hypermedia-driven interfaces.
- Keywords: jinja2, templates, partials, fragments, template composition, conditional rendering, htmx templates, template organization, reusable components, template context
- Depends: `221-python-htmx-core.md`

**`221b-python-htmx-flask.md`** - Flask-specific integration patterns for HTMX applications, covering Flask-HTMX extension usage, blueprint organization, route decorators, session management, and Flask-specific authentication patterns.
- Keywords: flask, flask-htmx, blueprints, flask-login, session management, flask routes, flask templates, flask csrf, flask extensions, request context
- Depends: `221-python-htmx-core.md`, `221a-python-htmx-templates.md`

**`221c-python-htmx-fastapi.md`** - FastAPI-specific integration patterns for HTMX applications, covering async route handlers, Jinja2 template configuration, dependency injection for HTMX detection, background task patterns with polling, and authentication strategies.
- Keywords: fastapi, async, dependency injection, background tasks, oauth2, jwt, fastapi templates, starlette, pydantic, async routes
- Depends: `221-python-htmx-core.md`, `221a-python-htmx-templates.md`

**`221d-python-htmx-testing.md`** - Testing strategies for HTMX endpoints in Python applications, covering unit tests for header validation, integration tests for partial responses, pytest fixtures for HTMX requests, HTML assertion patterns, and mocking strategies.
- Keywords: testing, pytest, unit tests, integration tests, fixtures, mocking, header validation, html assertions, test client, htmx testing
- Depends: `221-python-htmx-core.md`, `206-python-pytest.md`

**`221e-python-htmx-patterns.md`** - Reusable HTMX implementation patterns for common web application features including CRUD operations, form validation, infinite scroll, real-time updates, progressive enhancement, modals, search, and multi-step workflows.
- Keywords: crud, forms, validation, infinite scroll, lazy loading, sse, progressive enhancement, modals, search, autocomplete, real-time, polling, inline editing
- Depends: `221-python-htmx-core.md`, `221a-python-htmx-templates.md`

**`221f-python-htmx-integrations.md`** - Integration patterns for using HTMX with popular frontend libraries and frameworks including Alpine.js, _hyperscript, CSS frameworks (Tailwind, Bootstrap), icon libraries, and visualization libraries.
- Keywords: alpinejs, hyperscript, tailwind, bootstrap, css frameworks, icon libraries, chartjs, frontend libraries, client-side enhancements, htmx integration, javascript frameworks
- Depends: `221-python-htmx-core.md`

**`221g-python-htmx-sse.md`** - Patterns for implementing Server-Sent Events (SSE) in HTMX applications, covering the decision between HTMX SSE extension and Alpine.js SSE manager, event type matching, thread-safe publishing, and common anti-patterns that lead to broken real-time updates.
- Keywords: sse, server-sent events, htmx, alpine.js, eventsource, real-time, streaming, live updates, push notifications, event types, sse-manager
- Depends: `221-python-htmx-core.md`, `221f-python-htmx-integrations.md`

**`230-python-pydantic.md`** - Establish comprehensive data validation and serialization patterns using Pydantic v2, covering model design, settings management, custom validators, and integration strategies for building type-safe, validated Python applications.
- Keywords: Pydantic, data validation, models, settings, BaseModel, field validation, serialization, Field, validator, model_validator, EmailStr, pydantic-settings
- Depends: `200-python-core.md`

**`240-python-faker.md`** - Comprehensive patterns for generating realistic test data using Python's Faker library, covering setup, providers, localization, testing integration, and performance optimization to create maintainable and deterministic test suites.
- Keywords: Faker, test data generation, fake data, providers, localization, synthetic data, pytest fixtures, seeding, deterministic testing, Python testing
- Depends: `200-python-core.md`

**`250-python-flask.md`** - Comprehensive Flask development best practices, organized into focused patterns that cover all aspects of modern web application development including application architecture, security, templating, database integration, and deployment for building maintainable, secure web applications.
- Keywords: Flask, web development, blueprints, Flask-SQLAlchemy, templates, routing, Flask extensions, application factory, Jinja2, Flask-WTF, CSRF protection
- Depends: `200-python-core.md`

**`251-python-datetime-handling.md`** - Comprehensive datetime handling practices across Python, Pandas, Plotly, and Streamlit to prevent type errors, timezone bugs, and performance issues while ensuring Pandas 2.x compatibility and cross-library interoperability.
- Keywords: datetime, pandas, timezone, datetime64, timedelta, UTC, date arithmetic, tz_localize, tz_convert, datetime.now(UTC)
- Depends: `200-python-core.md`

**`252-python-pandas.md`** - Comprehensive Pandas best practices focusing on vectorization, performance optimization, memory efficiency, and anti-pattern avoidance to prevent common issues like 100x+ performance slowdowns, SettingWithCopyWarning errors, and memory exhaustion in data-intensive workflows.
- Keywords: pandas, DataFrame, vectorization, SettingWithCopyWarning, memory optimization, dtypes, groupby, merge, performance, method chaining
- Depends: `200-python-core.md`


### Shell Scripting (300-series)

**`300-bash-scripting-core.md`** - Foundational bash scripting patterns covering script structure, variables, functions, and essential error handling practices to create reliable, maintainable, and portable shell scripts.
- Keywords: Bash, shell scripting, set -euo pipefail, error handling, strict mode, functions, variables, script structure, trap, exit codes, shellcheck, input validation
- Depends: `000-global-core.md`

**`300a-bash-security.md`** - Comprehensive bash scripting security practices covering input validation, path security, permissions, and secure coding patterns to prevent vulnerabilities and ensure safe script execution.
- Keywords: Bash, security, input validation, command injection, path security, secure shell scripts, sanitization, permissions, privilege escalation, secrets management
- Depends: `300-bash-scripting-core.md`

**`300b-bash-testing-tooling.md`** - Comprehensive bash testing, debugging, and modern tooling integration including ShellCheck, CI/CD workflows, and development practices to ensure script quality and reliability.
- Keywords: Bash, testing, ShellCheck, bats, shell script testing, CI/CD, debugging, static analysis, linting, test automation
- Depends: `300-bash-scripting-core.md`

**`310-zsh-scripting-core.md`** - Foundational zsh scripting patterns covering unique zsh features, script structure, variables, functions, and essential practices to leverage zsh's advanced capabilities while maintaining compatibility.
- Keywords: Zsh, Z shell, zsh features, arrays, functions, oh-my-zsh, emulate, setopt, parameter expansion, globbing
- Depends: `300-bash-scripting-core.md`

**`310a-zsh-advanced-features.md`** - Comprehensive guidance on zsh's advanced features including the completion system, modules, hooks, and performance optimization techniques to build sophisticated and efficient zsh environments.
- Keywords: Zsh, completion system, modules, hooks, advanced features, performance optimization, compinit, zstyle, autoload, scripting
- Depends: `310-zsh-scripting-core.md`

**`310b-zsh-compatibility.md`** - Zsh compatibility strategies, bash migration patterns, and cross-shell scripting best practices for mixed environments, ensuring seamless transitions and portable script solutions.
- Keywords: Zsh, shell compatibility, bash vs zsh, portable scripts, cross-shell, migration, emulate, POSIX compliance, scripting, shell scripting
- Depends: `300-bash-scripting-core.md`


### Docker/Containers (300-series)

**`350-docker-best-practices.md`** - Provides practical, production-ready guidance for authoring Dockerfiles, building images, and running containers securely and efficiently, minimizing image size, build time, and supply-chain risk.
- Keywords: Docker, Dockerfile, containers, multi-stage builds, layer caching, image optimization, docker-compose, BuildKit, distroless, security scanning, SBOM, non-root, healthcheck
- Depends: `000-global-core.md`, `202-markup-config-validation.md`


### JavaScript/TypeScript (400-series)

**`420-javascript-core.md`** - Definitive standards for writing modern, robust JavaScript in 2025, enforcing ECMAScript Modules (ESM), immutable data patterns (ES2023+ methods), type safety via JSDoc, and modern tooling (Biome, Node Native Test Runner).
- Keywords: JavaScript, ES2024, ESM, Node.js, JSDoc, Biome, node:test, Immutability, Async/Await, Functional Programming
- Depends: `000-global-core.md`

**`421-javascript-alpinejs-core.md`** - Provides comprehensive guidance for Alpine.js 3.x, a lightweight JavaScript framework for composing behavior directly in HTML markup through declarative directives, reactive data, and magic properties for progressive enhancement and interactive components.
- Keywords: Alpine.js, reactivity, x-data, x-bind, x-on, x-model, x-show, x-if, magic properties, $el, $refs, $store, declarative, progressive enhancement, lightweight
- Depends: `000-global-core.md`

**`430-typescript-core.md`** - Establishes the definitive standards for writing production-grade TypeScript in 2025. This rule enforces **Strict Mode**, prioritizes **Type Inference** over manual typing, mandates **Runtime Validation** (Zod) at I/O boundaries, and explicitly forbids legacy features like Enums and Namespaces.
- Keywords: TypeScript, Zod, Strict Mode, Type Inference, Union Types, Satisfies, Generics, Utility Types, Matt Pocock, Total TypeScript
- Depends: `000-global-core.md`


### React/Frontend (400-series)

**`440-react-core.md`** - Establishes the definitive standards for developing scalable, maintainable React applications in 2025. This rule enforces "Feature-based" architecture, Server Components (RSC) usage, and modern state management patterns to replace legacy approaches like global Redux or huge `useEffect` chains.
- Keywords: React, Next.js, RSC, Hooks, Tailwind, Zustand, TanStack Query, Shadcn, Feature-based, TypeScript, Vitest, Testing Library, debug hooks, fix React error, component rendering
- Depends: `000-global-core.md`, `420-javascript-core.md`, `430-typescript-core.md`

**`441-react-backend.md`** - Establishes backend integration patterns for React applications, with Python (FastAPI/Flask) as the organizational default. Covers API communication, authentication flows, CORS configuration, and type sharing between frontend and backend.
- Keywords: React backend, FastAPI, Flask, Python API, CORS, JWT, authentication, API integration, full-stack, Express alternative, fetch, axios, TanStack Query backend, Next.js API routes, httpOnly cookies
- Depends: `440-react-core.md`, `200-python-core.md`


### Frontend/HTMX (500-series)

**`500-frontend-htmx-core.md`** - Provides a standalone frontend reference for HTMX attributes, client-side events, CSS transitions, debugging techniques, and browser compatibility considerations for pure HTMX usage without backend specifics.
- Keywords: htmx attributes, client-side, events, css transitions, debugging, browser compatibility, hx-get, hx-post, hx-swap, hx-trigger, hx-target
- Depends: `000-global-core.md`


### Go/Systems (600-series)

**`600-golang-core.md`** - Foundational Go development practices using idiomatic patterns, modern tooling (Go 1.21+), and industry-standard conventions to ensure reliable, maintainable, and performant Go codebases.
- Keywords: Go, Golang, go.mod, modules, error handling, interfaces, goroutines, channels, testing, go fmt, golangci-lint, concurrency, context, defer
- Depends: `000-global-core.md`


### Project Management (800-series)

**`800-project-changelog.md`** - Maintaining high-signal, audit-friendly CHANGELOG.md following Keep a Changelog standard with Conventional Commits format for consistent project change documentation.
- Keywords: CHANGELOG, changelog format, semantic versioning, release notes, conventional commits, Unreleased section, scope patterns, project governance, git workflow, version control
- Depends: `000-global-core.md`

**`801-project-readme.md`** - Comprehensive standards for README.md files following widely accepted industry best practices, ensuring consistent, professional, and accessible project documentation that serves both technical and non-technical audiences.
- Keywords: README, project documentation, getting started, setup instructions, badges, Quick Start, Contributing, License, project structure, technical writing
- Depends: `000-global-core.md`

**`802-project-contributing.md`** - Professional contribution workflow directives covering commits, pull requests, changelog discipline, and rule authoring standards to ensure consistent project collaboration and quality.
- Keywords: CONTRIBUTING, pull requests, code review, contribution guidelines, branching strategy, Conventional Commits, rule authoring, PR templates, project governance, git workflow
- Depends: `000-global-core.md`

**`803-project-git-workflow.md`** - Comprehensive git workflow best practices for managing project updates on GitHub, including commit message formatting, branching strategies, proper workflows, and robust validation before integration.
- Keywords: git, git commit, commit, commit message, commit messages, staging, staged changes, workflow, branching strategy, GitHub, pull requests, feature branches, protected branches, git validation, branch naming, PR workflow, Conventional Commits, conventional commit format
- Depends: `800-project-changelog.md`, `802-project-contributing.md`

**`820-taskfile-automation.md`** - Directives for creating, modifying, and maintaining project automation using Taskfile.yml as the primary orchestrator, ensuring consistent, portable, and well-documented task management across development workflows.
- Keywords: Taskfile, Taskfile.yml, task automation, build automation, task runner, Task, portable tasks, error handling, categorized help, task discovery, command detection, auto-detection, cross-platform, uvx, machine-readable
- Depends: `202-markup-config-validation.md`


### Demo/Analytics (900-series)

**`920-data-science-analytics.md`** - Comprehensive rules for data science and analytics on Snowflake. Covers model lifecycle management, ML/AI insight presentation, advanced SQL techniques, performance optimization, and ethical visualization practices to ensure reproducible, performant, and trustworthy analytical workflows.
- Keywords: Data science, Snowflake, pandas, Snowpark, ML, model lifecycle, feature engineering, NaN handling, model versioning, Jupyter
- Depends: `200-python-core.md`, `000-global-core.md`

**`930-data-governance-quality.md`** - Comprehensive directives for ensuring data quality, governance, and operational reliability throughout the data lifecycle. Covers code-based validation, schema evolution management, automated quality gates, data lineage, and incident response.
- Keywords: Data governance, data quality, lineage, metadata management, compliance, data catalog, Great Expectations, schema evolution, data observability, incident response
- Depends: `000-global-core.md`

**`940-business-analytics.md`** - Comprehensive directives for creating business-oriented queries, reports, dashboards, and visualizations targeted at non-technical stakeholders. Emphasizes clarity, actionable insights, ethical presentation, accessibility (WCAG 2.1 AA), effective data storytelling, and Snowflake-native dashboard capabilities.
- Keywords: Business intelligence, dashboards, KPIs, reporting, visualization, stakeholder reports, metrics, Snowsight, executive dashboards, data storytelling, WCAG accessibility
- Depends: `000-global-core.md`, `100-snowflake-core.md`


---

## Common Rule Dependency Chains

Two representative examples demonstrating all dependency patterns. Apply these patterns to other rule combinations using the Depends field in the catalog above.

**Reading the Chains:**
- Indentation shows dependency relationships
- Token budgets shown in parentheses
- "Minimal/Standard/Complete" shows progressive loading strategies

### Example 1: Linear Chain (Streamlit Dashboard)

**`000-global-core.md`** (3300 tokens) - Foundation
- **`100-snowflake-core.md`** (2850 tokens) - Snowflake foundation
  - **`101-snowflake-streamlit-core.md`** (3700 tokens) - Streamlit core
    - **`101a-snowflake-streamlit-visualization.md`** (3600 tokens) - Visualization
    - **`101b-snowflake-streamlit-performance.md`** (5950 tokens) - Performance
    - **`101c-snowflake-streamlit-security.md`** (2550 tokens) - Security

**Token Cost Scenarios:**
- Minimal (basic app): 000 + 100 + 101 = ~9,850 tokens
- Standard (with viz): + 101a = ~13,450 tokens
- Complete (production-ready): + 101b + 101c = ~21,950 tokens

### Example 2: Multi-Branch (Cortex Agent)

**`000-global-core.md`** (3300 tokens) - Foundation
- **`100-snowflake-core.md`** (2850 tokens) - Snowflake foundation
  - **`106-snowflake-semantic-views-core.md`** (5550 tokens) - Semantic views
  - **`111-snowflake-observability-core.md`** (4200 tokens) - Observability
- **`115-snowflake-cortex-agents-core.md`** (4650 tokens) - Cortex agents
  - **`115a-snowflake-cortex-agents-instructions.md`** (3450 tokens) - Instructions
  - **`115b-snowflake-cortex-agents-operations.md`** (3650 tokens) - Operations

**Token Cost Scenarios:**
- Minimal (agent setup): 000 + 100 + 115 = ~10,800 tokens
- Standard (+ semantic): + 106 = ~16,350 tokens
- Production (+ ops): + 115b + 111 = ~24,200 tokens

**Usage Tips:**
- "Minimal" covers 70-80% of typical use cases
- Start minimal, add rules as complexity requires
- Check Depends field for prerequisites
