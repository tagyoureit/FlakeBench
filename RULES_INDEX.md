<!--
╔══════════════════════════════════════════════════════════════════════════╗
║                           AUTO-GENERATED FILE                             ║
║                    DO NOT EDIT THIS FILE MANUALLY                         ║
╚══════════════════════════════════════════════════════════════════════════╝

Generated by: scripts/index_generator.py
Last updated: 2025-12-16 11:48:38

To regenerate this index:
  1. Make changes to rule files in rules/ directory
  2. Run: task index:generate
  3. Commit both rule files AND RULES_INDEX.md together

This index provides semantic discovery for AI agents.
-->

# Rules Index

This index provides semantic rule discovery for AI agents. All rules in `rules/` are production-ready and deployment-ready.

**How to Use This Index:**
- Browse by category (000=Core, 100=Snowflake, 200=Python, 300=Shell, 400=Docker, 500-900=Domain-specific)
- Search Keywords column for semantic discovery (technologies, patterns, use cases)
- Check Depends On column for prerequisite rules


|| File | Scope | Keywords/Hints | Depends On |
||------|-------|----------------|------------|
|| `000-global-core.md` | Universal foundational guidelines for all AI coding assistants across all editors and technologies | PLAN mode, ACT mode, workflow, safety, confirmation, validation, surgical edits, minimal changes, mode violations, prompt engineering, task list, read-only, authorization | — |
|| `001-memory-bank.md` | Universal memory bank principles for project context management across all AI models and editors | memory bank, context, session recovery, project brief, active context, progress tracking, continuity, context rot, attention budget, compaction, context engineering, rapid recovery, signal maximization | `rules/000-global-core.md` |
|| `002-rule-governance.md` | All rule files in the ai_coding_rules repository must comply with v3.0 schema standards defined in schemas/rule-schema-v3.yml | rule governance, v3.0 schema, metadata requirements, required sections, Contract XML tags, validation, schema compliance, rule structure, semantic discovery, RULES_INDEX | `rules/000-global-core.md` |
|| `002a-rule-creation-guide.md` | All AI agents creating new rule files in the ai_coding_rules repository. | rule creation, workflow, step-by-step guide, naming conventions, metadata setup, section structure, Contract XML, validation, rule numbering, from scratch | `rules/002-rule-governance.md`, `rules/000-global-core.md` |
|| `002b-rule-optimization.md` | All AI agents creating, maintaining, or loading rule files in the ai_coding_rules repository. | token budget, optimization, performance, rule sizing, progressive loading, context window, model limits, cost efficiency, caching, batch loading | `rules/002-rule-governance.md`, `rules/000-global-core.md` |
|| `002c-advanced-rule-patterns.md` | AI agents writing complex rules requiring advanced patterns, anti-pattern libraries, or multi-step workflows. | system prompt altitude, investigation-first, anti-patterns, multi-session workflows, parallel execution, advanced patterns, heuristics, goldilocks zone, context management, state management | `rules/002-rule-governance.md`, `rules/000-global-core.md` |
|| `002d-schema-validator-usage.md` | All AI agents validating rule files against schemas/rule-schema-v3.yml. | schema validator, validation errors, error resolution, CI/CD integration, exit codes, command selection, output parsing, automation workflow, JSON output, quiet mode, programmatic integration, regex patterns, error categorization | `rules/002-rule-governance.md`, `rules/000-global-core.md` |
|| `003-context-engineering.md` | Universal context management principles for all AI agents across all models (Claude, GPT, Gemini) and editors | context engineering, attention budget, context rot, token efficiency, compaction, progressive disclosure, sub-agents, agentic search, system prompts, right altitude, long-horizon tasks, memory management, state tracking | `rules/000-global-core.md` |
|| `004-tool-design-for-agents.md` | Tool development for AI agents across all platforms (Claude, GPT, Gemini) and frameworks | tool design, agent tools, token efficiency, tool parameters, function calling, tool overlap, tool contracts, error handling, minimal tool set, self-contained tools, LLM-friendly parameters, single responsibility | `rules/000-global-core.md`, `rules/003-context-engineering.md` |
|| `100-snowflake-core.md` | Foundational Snowflake development practices across all SQL, data modeling, and platform features | SQL, CTE, performance, cost optimization, query profile, warehouse, security, governance, stages, COPY INTO, streams, tasks, warehouse creation | `rules/000-global-core.md` |
|| `100f-snowflake-connection-errors.md` | Connection error handling for `snowflake-connector-python` across Python scripts, CLI tools, REST APIs, Streamlit apps, and Snowpark applications. | connection errors, error classification, network policy, authentication, VPN, error codes, 08001, 390114, error handling, snowflake.connector, DatabaseError, message analysis, error detection | `rules/100-snowflake-core.md` |
|| `101-snowflake-streamlit-core.md` | Streamlit core application architecture, multipage navigation, deployment modes, configuration management | Streamlit, SPCS, st.connection, session state, navigation, multipage, deployment, dashboard, pandas, NaN, NULL handling, session management, connection management | `rules/100-snowflake-core.md` |
|| `101a-snowflake-streamlit-visualization.md` | Streamlit data visualization using Plotly, chart configuration, map rendering, dashboard integration | st.plotly_chart, st.map, dashboard, interactive charts, map visualization, time series smoothing, data aggregation, create chart, chart types, plotly express, dashboard layout, chart configuration, streamlit plotting, chart customization | `rules/101-snowflake-streamlit-core.md`, `rules/940-business-analytics.md` |
|| `101b-snowflake-streamlit-performance.md` | Streamlit performance optimization, caching patterns, Snowflake data loading, SQL error handling and debugging, progress indicators | @st.cache_data, @st.cache_resource, SQL error handling, st.error, SnowparkSQLException, st.fragment, NULL handling, slow streamlit, streamlit caching, optimize streamlit, fix slow queries, fragment batch processing | `rules/101-snowflake-streamlit-core.md`, `rules/103-snowflake-performance-tuning.md` |
|| `101c-snowflake-streamlit-security.md` | Streamlit security, input validation, secrets management, authentication | st.secrets, SQL injection, authentication, secure streamlit, protect app, credentials management, API keys, environment variables, secure deployment, input sanitization, RBAC streamlit, access control, security patterns | `rules/101-snowflake-streamlit-core.md`, `rules/107-snowflake-security-governance.md` |
|| `101d-snowflake-streamlit-testing.md` | Streamlit testing with AppTest, unit testing data functions, debugging patterns | test Streamlit app, pytest, test framework, test patterns, app testing, UI testing, test automation, streamlit test suite, integration testing, test coverage, debug tests, test fixtures, testing strategies | `rules/101-snowflake-streamlit-core.md`, `rules/206-python-pytest.md` |
|| `101e-snowflake-streamlit-sql-errors.md` | Detailed SQL error handling patterns and examples | SnowparkSQLException, error messages, Streamlit errors, Snowflake errors, debug SQL error, fix query error, SQL exception, error troubleshooting, query failed, database error, SQL debugging patterns, exception handling, error recovery, common SQL errors | `rules/100-snowflake-core.md`, `rules/101-snowflake-streamlit-core.md`, `rules/101b-snowflake-streamlit-performance.md` |
|| `102-snowflake-sql-demo-engineering.md` | Demo SQL files, workshop materials, customer learning environments, quickstart guides | teardown, customer_load.sql, inline documentation, progress indicators, rerunnable demos, Snowflake SQL, CREATE OR REPLACE, educational SQL, demo patterns, demo data, setup scripts, demo automation, learning examples | `rules/100-snowflake-core.md` |
|| `102a-snowflake-sql-automation.md` | Production SQL templates, CI/CD pipelines, multi-environment deployments, automated workflows | idempotent, MERGE, operations, multi-environment, infrastructure as code, Snowflake variables, production-safe, upsert, SQL automation, deployment scripts, SQL pipeline, config management, environment variables | `rules/100-snowflake-core.md`, `rules/102-snowflake-sql-demo-engineering.md` |
|| `103-snowflake-performance-tuning.md` | Snowflake query performance tuning, warehouse optimization, and cost management | search optimization, pruning, spillage, SQL optimization, Snowflake, partition pruning, QUERY_HISTORY, optimize query, fix slow query, query bottleneck, warehouse performance, micro-partitions, clustering, performance analysis | `rules/100-snowflake-core.md` |
|| `104-snowflake-streams-tasks.md` | Snowflake Streams and Tasks for incremental data pipelines and automated workflows | scheduled tasks, pipeline automation, MERGE patterns, SQL, Snowflake, task DAG, AFTER dependencies, Task History, create stream, create task, debug stream, task troubleshooting, stream consumption, task execution error, stream lag | `rules/100-snowflake-core.md` |
|| `105-snowflake-cost-governance.md` | Snowflake cost management, resource monitors, and credit usage optimization | budget alerts, spend tracking, Snowflake, SQL, CREDIT_QUOTA, WAREHOUSE_METERING_HISTORY, object tagging, monitor credits, warehouse spending, cost alerts, credit limits, budget management, resource monitor, tag enforcement | `rules/100-snowflake-core.md` |
|| `106-snowflake-semantic-views-core.md` | Snowflake native semantic view DDL creation and validation | TABLES, RELATIONSHIPS, PRIMARY KEY, validation rules, semantic view error, create semantic view, debug semantic view, SQL, verified queries, VQR, YAML semantic model, NLQ, mapping syntax, granularity rules | `rules/100-snowflake-core.md` |
|| `106a-snowflake-semantic-views-advanced.md` | Anti-patterns, validation rules, quality checks, compliance | compliance, common mistakes, validation rules, semantic model quality, semantic view pitfalls, debug semantic view, fix semantic view errors, validation failures, relationship errors, mapping errors, quality assurance, semantic view testing, validation patterns | `rules/100-snowflake-core.md`, `rules/106-snowflake-semantic-views-core.md` |
|| `106b-snowflake-semantic-views-querying.md` | Querying semantic views after creation, testing patterns, validation strategies | window functions, dimension compatibility, testing, validation, TPC-DS, performance optimization, aliases, granularity, query semantic view, semantic view results, query patterns, result processing, SEMANTIC_VIEW function, query errors, dimension filters | `rules/106-snowflake-semantic-views-core.md` |
|| `106c-snowflake-semantic-views-integration.md` | Cortex integration, governance patterns, development workflows, Generator usage | RBAC, masking policy, row access policy, Generator workflow, iterative development, synonyms, natural language queries, cortex analyst, agent integration, semantic view security, analyst troubleshooting, fix analyst, debug analyst | `rules/106-snowflake-semantic-views-core.md`, `rules/106b-snowflake-semantic-views-querying.md` |
|| `107-snowflake-security-governance.md` | Snowflake security governance, RBAC, data masking, access control policies, and data quality monitoring best practices | roles, grants, secure views, security policies, access control, data security, policy troubleshooting, grant management, Data Metric Functions, DMF, least privilege, create masking policy, tagging, SQL | `rules/100-snowflake-core.md` |
|| `108-snowflake-data-loading.md` | Snowflake data staging and bulk loading with Stages and COPY INTO commands (for continuous ingestion with Snowpipe, see `121-snowflake-snowpipe.md`) | bulk loading, ON_ERROR, FILE_FORMAT, load data, external stage, internal stage, data ingestion, file upload, COPY error, loading patterns, stage files, PUT command, GET command | `rules/100-snowflake-core.md` |
|| `109-snowflake-notebooks.md` | Jupyter Notebooks in Snowflake with Snowpark for Python and reproducible data science workflows | ML, reproducible notebooks, nbqa, notebook linting, code quality, Python, create notebook, debug notebook, notebook execution, notebook testing, notebook deployment, kernel management, cell execution | `rules/100-snowflake-core.md`, `rules/201-python-lint-format.md` |
|| `109a-snowflake-notebooks-tutorials.md` | Tutorial and learning design for Snowflake notebooks, educational content, and self-paced learning materials | checkpoints, learning objectives, pedagogical design, educational content, progressive learning, Snowflake notebooks, teaching point callouts, validation gates, tutorial structure, learning design, educational notebooks, teaching methodology, notebook education | `rules/109-snowflake-notebooks.md`, `rules/920-data-science-analytics.md` |
|| `109b-snowflake-app-deployment-core.md` | Deployment automation for Snowflake applications using internal stages, covering notebooks, Streamlit apps, UDFs, and stored procedures | CREATE NOTEBOOK, stages, deployment automation, SiS, deploy app, deployment pipeline, app publishing, deployment patterns, deploy to snowflake, stage deployment, production deployment, app versioning, automated deployment | `rules/100-snowflake-core.md`, `rules/109-snowflake-notebooks.md`, `rules/101-snowflake-streamlit-core.md`, `rules/820-taskfile-automation.md` |
|| `109c-snowflake-app-deployment-troubleshooting.md` | Debugging and troubleshooting deployment issues for notebooks, Streamlit apps, UDFs, and stored procedures in Snowflake | Snowflake deployment troubleshooting, Streamlit debugging, SiS TypeError, notebook deployment issues, deployment errors, stage file debugging, AUTO_COMPRESS debugging, ROOT_LOCATION errors, deployment anti-patterns, diagnostic commands, deployment validation, cache issues | `rules/100-snowflake-core.md`, `rules/109-snowflake-notebooks.md`, `rules/101-snowflake-streamlit-core.md`, `rules/109b-snowflake-app-deployment-core.md` |
|| `110-snowflake-model-registry.md` | Snowflake Model Registry operations including model logging, versioning, access control, inference, and lifecycle management for Python ML models | model governance, model lifecycle, model logging, model inference, RBAC, model privileges, register model, log model, model management, ML registry, model tracking, model metadata, deploy model, model lineage | `rules/100-snowflake-core.md` |
|| `111-snowflake-observability-core.md` | Snowflake observability foundations, telemetry configuration, event table setup, and basic patterns | LOG_LEVEL, TRACE_LEVEL, METRIC_LEVEL, SHOW PARAMETERS, OpenTelemetry, System Views vs Telemetry, monitoring, logging, tracing, debug observability, event table queries, observability patterns, configure telemetry | `rules/100-snowflake-core.md` |
|| `111a-snowflake-observability-logging.md` | Logging patterns for Python, Java/Scala, and JavaScript handlers in Snowflake environments | DEBUG, INFO, WARN, ERROR, FATAL, conditional logging, sampling, tight loop logging, standard logging libraries, log volume control, cost management, log configuration, log handlers | `rules/100-snowflake-core.md`, `rules/111-snowflake-observability-core.md` |
|| `111b-snowflake-observability-tracing.md` | Distributed tracing with `snowflake-telemetry-python` package and metrics collection for Snowflake handlers | span attributes, trace_id, performance analysis, metrics collection, cpu_usage, memory_usage, telemetry.create_span, OpenTelemetry, nested spans, tracing patterns, span creation, trace analysis, distributed traces | `rules/100-snowflake-core.md`, `rules/111-snowflake-observability-core.md` |
|| `111c-snowflake-observability-monitoring.md` | Monitoring queries, Snowsight navigation, cost management, AI observability, troubleshooting patterns | Copy History, Task History, Dynamic Tables, cost management, AI observability, Cortex AI, token tracking, troubleshooting, performance analysis, monitor queries, monitoring dashboard, observability UI, query monitoring, telemetry volume, SQL | `rules/100-snowflake-core.md`, `rules/111-snowflake-observability-core.md` |
|| `112-snowflake-snowcli.md` | Snowflake CLI usage across local development, scripts, Taskfile targets, and CI/CD pipelines | snow CLI, SnowCLI, Snowflake command line, uvx snow, CLI deployment, snowflake.yml, uvx --from snowflake-cli, pinned execution, hermetic execution, snow commands, snowflake CLI usage, CLI automation, command line tools, CLI configuration, CLI deployment patterns | `rules/100-snowflake-core.md` |
|| `113-snowflake-feature-store.md` | Snowflake Feature Store (Enterprise Edition), feature engineering, entity modeling, feature views, ML dataset creation, and Model Registry integration | feature views, entity modeling, ML pipeline, ASOF JOIN, point-in-time correctness, Dynamic Tables, feature versioning, create features, feature catalog, feature pipeline, feature discovery, feature registry, feature lineage | `rules/100-snowflake-core.md`, `rules/110-snowflake-model-registry.md` |
|| `114-snowflake-cortex-aisql.md` | AISQL functions (`AI_COMPLETE`, `AI_CLASSIFY`, `AI_FILTER`, `AI_AGG`, `AI_SUMMARIZE_AGG`, `AI_EMBED`, `AI_EXTRACT`, `AI_SENTIMENT`, `AI_SIMILARITY`, `AI_TRANSCRIBE`, `AI_PARSE_DOCUMENT`, `AI_TRANSLATE`) and helper functions (`PROMPT`, `AI_COUNT_TOKENS`, `TO_FILE`), SQL and Snowpark Python usage, governance (CORTEX_USER), and observability. | Cortex AISQL, AI_COMPLETE, AI_CLASSIFY, AI_EXTRACT, AI_SENTIMENT, AI_SUMMARIZE, embeddings, LLM functions, batching, token costs, text generation, classification, sentiment analysis, summarization, AI function error | `rules/100-snowflake-core.md`, `rules/105-snowflake-cost-governance.md` |
|| `115-snowflake-cortex-agents-core.md` | Cortex Agents creation and operation, agent archetypes, tool design and configuration, planning/response instructions, testing patterns, RBAC/allowlists, evaluation and tracing, cost/latency trade-offs | multi-tool agents, planning instructions, testing, troubleshooting, semantic views, create agent, debug agent, agent not working, tool execution failed, agent error, fix agent, agent performance, agent tool integration, cortex agent configuration, UnboundedExecution | `rules/100-snowflake-core.md`, `rules/105-snowflake-cost-governance.md`, `rules/106-snowflake-semantic-views-core.md`, `rules/111-snowflake-observability-core.md` |
|| `115a-snowflake-cortex-agents-instructions.md` | Planning instructions, response instructions, tool selection logic, agent orchestration patterns | Cortex Agents, planning instructions, response instructions, tool orchestration, flagging logic, agent prompts, multi-tool orchestration, tool selection, agent prompting, instruction patterns, agent planning | `rules/100-snowflake-core.md`, `rules/115-snowflake-cortex-agents-core.md` |
|| `115b-snowflake-cortex-agents-operations.md` | Testing, RBAC, allowlists, observability, evaluation, cost optimization, error resolution | observability, evaluation, cost management, error troubleshooting, agent security, test agent, agent permissions, agent monitoring, agent evaluation, agent costs, debug agent, agent logs, agent trace, agent security policies | `rules/100-snowflake-core.md`, `rules/115-snowflake-cortex-agents-core.md`, `rules/111-snowflake-observability-core.md` |
|| `116-snowflake-cortex-search.md` | Cortex Search indexing and querying; embedding creation; metadata and security filters; agent tool integration; observability and cost control | embeddings, search index, RAG, agent tools, retrieval, troubleshooting, AI_EMBED, create search service, search service error, document retrieval, search index creation, hybrid search, search service debug, vector similarity | `rules/100-snowflake-core.md`, `rules/105-snowflake-cost-governance.md`, `rules/111-snowflake-observability-core.md`, `rules/114-snowflake-cortex-aisql.md` |
|| `117-snowflake-mcp-server.md` | Applies whenever you create, secure, or use **Snowflake-managed MCP servers** from any MCP client (Cursor, Claude Desktop, custom clients, etc.). | MCP, Model Context Protocol, Snowflake-managed MCP server, CREATE MCP SERVER, SYSTEM_EXECUTE_SQL, CORTEX_ANALYST_MESSAGE, CORTEX_SEARCH_SERVICE_QUERY, CORTEX_AGENT_RUN, tools/list, tools/call, initialize, OAuth, SECURITY INTEGRATION, RBAC, PAT | `rules/100-snowflake-core.md`, `rules/107-snowflake-security-governance.md`, `rules/112-snowflake-snowcli.md` |
|| `118-snowflake-cortex-rest-api.md` | REST API usage for Complete, Embed, Agents; client patterns; when to use REST vs AISQL | idempotency, rate limits, Complete endpoint, Embed endpoint, exponential backoff, REST API, Cortex API, authentication tokens, PAT, OAuth, JWT, SSE, token verification, response format | `rules/100-snowflake-core.md`, `rules/105-snowflake-cost-governance.md`, `rules/111-snowflake-observability-core.md` |
|| `119-snowflake-warehouse-management.md` | Virtual warehouse creation, configuration, lifecycle management, type selection (Standard, Snowpark-Optimized, High-Memory), and cost optimization | high-memory warehouse, warehouse tagging, auto-suspend, auto-resume, GEN 2, Snowpark-Optimized, warehouse edition, resource monitors, create warehouse, warehouse configuration, warehouse types, warehouse cost, size warehouse | `rules/100-snowflake-core.md`, `rules/103-snowflake-performance-tuning.md`, `rules/105-snowflake-cost-governance.md` |
|| `120-snowflake-spcs.md` | Snowflake Snowpark Container Services, containerized applications, microservices | service deployment, compute pools, OCI images, image registry, health checks, GPU workloads, create service, compute pool, container deployment, service spec, container troubleshooting, SPCS error, service logs | `rules/100-snowflake-core.md` |
|| `121-snowflake-snowpipe.md` | Snowpipe serverless (auto-ingest and REST API) and Snowpipe Streaming (high-performance and classic architectures) for continuous data loading | streaming data, micro-batching, file-based ingestion, SDK, event notifications, COPY INTO, create pipe, auto ingest, data ingestion, streaming load, pipe errors, pipe management, ingestion monitoring | `rules/100-snowflake-core.md`, `rules/108-snowflake-data-loading.md`, `rules/104-snowflake-streams-tasks.md` |
|| `122-snowflake-dynamic-tables.md` | Snowflake Dynamic Tables for automated materialized views, incremental refresh patterns, and data pipeline orchestration | automatic pipelines, DOWNSTREAM, FULL, warehouse sizing, data freshness, create dynamic table, dynamic table lag, refresh frequency, dynamic table error, materialized view alternative, pipeline automation, lag configuration, refresh strategies | `rules/100-snowflake-core.md`, `rules/104-snowflake-streams-tasks.md`, `rules/119-snowflake-warehouse-management.md` |
|| `123-snowflake-object-tagging.md` | Snowflake object tagging for governance, cost tracking, data classification, policy enforcement, and metadata management | cost attribution, resource tagging, governance tags, masking policies, row access policies, tag lineage, create tags, apply tags, tag strategy, tag policies, tag compliance, tag hierarchy, tag discovery, tag management | `rules/100-snowflake-core.md`, `rules/105-snowflake-cost-governance.md`, `rules/107-snowflake-security-governance.md` |
|| `124-snowflake-data-quality-core.md` | Snowflake Data Quality Monitoring including system and custom DMFs, data profiling, expectations, scheduling, monitoring, and remediation workflows | data profiling, expectations, quality checks, data validation, NULL detection, uniqueness validation, freshness monitoring, anomaly detection, automated monitoring, event tables, create DMF, quality monitoring, data expectations, quality rules | `rules/100-snowflake-core.md`, `rules/105-snowflake-cost-governance.md`, `rules/107-snowflake-security-governance.md`, `rules/930-data-governance-quality.md` |
|| `124a-snowflake-data-quality-custom.md` | Custom DMFs, expectations, business rule validation | quality assertions, custom metrics, validation functions, create custom DMF, custom quality checks, business rule validation, custom expectations, quality functions, UDF for quality, validation logic, custom quality metrics, quality rules, custom validation | `rules/100-snowflake-core.md`, `rules/124-snowflake-data-quality-core.md` |
|| `124b-snowflake-data-quality-operations.md` | DMF scheduling, event tables, alerts, remediation, RBAC | remediation, RBAC, privilege requirements, automated monitoring, quality alerts, schedule DMF, quality event tables, quality alerting, DMF results, quality workflows, DMF RBAC, quality notifications, remediation workflows | `rules/100-snowflake-core.md`, `rules/124-snowflake-data-quality-core.md`, `rules/111-snowflake-observability-core.md` |
|| `125-snowflake-role-introspection.md` | Python scripts, Jupyter notebooks, and automation tools that introspect Snowflake roles, grants, and permission hierarchies | account roles, database roles, SHOW GRANTS, role introspection, RBAC, Python automation, error 000906, too many qualifiers, grants inspection, programmatic RBAC | `rules/000-global-core.md`, `rules/100-snowflake-core.md` |
|| `200-python-core.md` | Foundational Python development practices with modern tooling (uv, Ruff) and project structure | Python, uv, Ruff, pyproject.toml, dependency management, virtual environments, pytest, validation, uv run, uvx, ty, type checking, mypy, type hints | `rules/000-global-core.md` |
|| `201-python-lint-format.md` | Python code linting and formatting with Ruff for consistent code quality and style | Ruff, linting, formatting, code quality, style checking, uvx ruff, lint errors, ruff check, ruff format, pyproject.toml configuration | `rules/200-python-core.md` |
|| `202-markup-config-validation.md` | Markup and configuration file validation best practices (YAML, TOML, environment files, Markdown) | YAML, configuration files, YAML syntax, parsing errors, indentation, anchors, aliases, Markdown, markdown linting, pymarkdownlnt, markup validation, TOML, environment files | — |
|| `203-python-project-setup.md` | Python project setup, packaging, and dependency management with modern build tools | Python packaging, project structure, setup.py, pyproject.toml, dependencies, package distribution, __init__.py, hatchling, uv, src layout | `rules/200-python-core.md` |
|| `204-python-docs-comments.md` | Python comments, docstrings, and developer-facing documentation across libraries, apps, CLIs, and services | Python docstrings, documentation, comments, pydocstyle, Ruff DOC rules, API documentation, Google style, NumPy style, PEP 257, code quality, semantic depth, side effects, preconditions, performance, thread safety | `rules/200-python-core.md`, `rules/201-python-lint-format.md` |
|| `205-python-classes.md` | Class design patterns and usage in Python 3.11+ (data models, behavior, encapsulation, inheritance, protocols, ABCs) | Python classes, OOP, inheritance, dataclasses, @property, class design, encapsulation, composition, Protocol, ABC, type hints | `rules/200-python-core.md`, `rules/201-python-lint-format.md`, `rules/204-python-docs-comments.md` |
|| `206-python-pytest.md` | pytest usage for Python 3.11+ projects (test layout, fixtures, parametrization, isolation, markers, CI integration) | pytest, testing, fixtures, parametrization, test isolation, mocking, test organization, coverage, AAA pattern, test markers, uv run pytest | `rules/200-python-core.md`, `rules/201-python-lint-format.md`, `rules/203-python-project-setup.md` |
|| `207-python-logging.md` | Python applications using the `logging` module, especially those with dual output requirements (CLI and web UI) | logging, Python logging, logger, handlers, formatters, log levels, WebLogHandler, Rich console, SSE streaming, structured logging, operation ID, thread safety, log hierarchy, log propagation | `rules/200-python-core.md` |
|| `210-python-fastapi-core.md` | FastAPI web API development with modern Python patterns, async/await, and Pydantic integration | FastAPI, async, REST API, Pydantic, dependency injection, routing, request validation, response models, APIRouter, uvicorn, async def, application factory | `rules/200-python-core.md` |
|| `210a-python-fastapi-security.md` | FastAPI security patterns for authentication, authorization, CORS, and security middleware | FastAPI security, authentication, OAuth2, JWT, CORS, middleware, API keys, security best practices, bcrypt, HTTPBearer, role-based access control, RBAC | `rules/210-python-fastapi-core.md` |
|| `210b-python-fastapi-testing.md` | FastAPI testing strategies with TestClient, pytest-asyncio, and comprehensive API testing patterns | FastAPI testing, TestClient, pytest-asyncio, API tests, integration testing, mocking, test fixtures, AAA pattern, async testing, Python | `rules/210-python-fastapi-core.md` |
|| `210c-python-fastapi-deployment.md` | FastAPI production deployment with Docker, ASGI servers, and API documentation patterns | FastAPI deployment, Uvicorn, Gunicorn, ASGI, Docker, production deployment, health checks, multi-stage build, OpenAPI, API documentation | `rules/210-python-fastapi-core.md` |
|| `210d-python-fastapi-monitoring.md` | FastAPI health checks, logging, monitoring, and performance optimization patterns | FastAPI monitoring, health checks, logging, metrics, caching, Redis, observability, structured logging, health endpoints, correlation IDs | `rules/210-python-fastapi-core.md` |
|| `220-python-typer-cli.md` | Python CLI development, command-line applications, user interfaces | Typer, CLI development, command-line interface, click, argument parsing, CLI testing, typer.Argument, typer.Option, CliRunner, rich console | `rules/200-python-core.md` |
|| `221-python-htmx-core.md` | Python backend applications using HTMX for hypermedia-driven interactions (Flask, FastAPI, Django, or other Python web frameworks) | htmx, hypermedia, hateoas, hx-request, hx-trigger, partial rendering, sse, websockets, csrf, xss, http headers, swap strategies, oob swaps, response patterns | `rules/200-python-core.md` |
|| `221a-python-htmx-templates.md` | Python web applications using Jinja2 templates with HTMX (applies to Flask, FastAPI, Django with Jinja2, and other Python frameworks) | jinja2, templates, partials, fragments, template composition, conditional rendering, htmx templates, template organization, reusable components, template context | `rules/221-python-htmx-core.md` |
|| `221b-python-htmx-flask.md` | Flask web applications integrating HTMX for hypermedia-driven interfaces | flask, flask-htmx, blueprints, flask-login, session management, flask routes, flask templates, flask csrf, flask extensions, request context | `rules/221-python-htmx-core.md`, `rules/221a-python-htmx-templates.md` |
|| `221c-python-htmx-fastapi.md` | FastAPI web applications integrating HTMX for hypermedia-driven interfaces with async/await patterns | fastapi, async, dependency injection, background tasks, oauth2, jwt, fastapi templates, starlette, pydantic, async routes | `rules/221-python-htmx-core.md`, `rules/221a-python-htmx-templates.md` |
|| `221d-python-htmx-testing.md` | Python web applications (Flask, FastAPI, Django) with HTMX integration requiring comprehensive test coverage | testing, pytest, unit tests, integration tests, fixtures, mocking, header validation, html assertions, test client, htmx testing | `rules/221-python-htmx-core.md`, `rules/206-python-pytest.md` |
|| `221e-python-htmx-patterns.md` | Python web applications implementing common interactive patterns with HTMX (applicable to Flask, FastAPI, Django) | crud, forms, validation, infinite scroll, lazy loading, sse, progressive enhancement, modals, search, autocomplete, real-time, polling, inline editing | `rules/221-python-htmx-core.md`, `rules/221a-python-htmx-templates.md` |
|| `221f-python-htmx-integrations.md` | HTMX applications integrating with frontend libraries for enhanced interactivity and styling | alpinejs, hyperscript, tailwind, bootstrap, css frameworks, icon libraries, chartjs, frontend libraries, client-side enhancements, htmx integration, javascript frameworks | `rules/221-python-htmx-core.md` |
|| `230-python-pydantic.md` | Python data validation, model definition, settings management | Pydantic, data validation, models, settings, BaseModel, field validation, serialization, Field, validator, model_validator, EmailStr, pydantic-settings | `rules/200-python-core.md` |
|| `240-python-faker.md` | Python testing, data generation, test fixtures, development utilities | Faker, test data generation, fake data, providers, localization, synthetic data, pytest fixtures, seeding, deterministic testing, Python testing | `rules/200-python-core.md` |
|| `250-python-flask.md` | Flask web application development with modern patterns, security, and maintainable architecture | Flask, web development, blueprints, Flask-SQLAlchemy, templates, routing, Flask extensions, application factory, Jinja2, Flask-WTF, CSRF protection | `rules/200-python-core.md` |
|| `251-python-datetime-handling.md` | DateTime handling for Python stdlib, Pandas, Plotly, Streamlit with focus on type safety, timezone management, date arithmetic, and performance optimization | datetime, pandas, timezone, datetime64, timedelta, UTC, date arithmetic, tz_localize, tz_convert, datetime.now(UTC) | `rules/200-python-core.md` |
|| `252-pandas-best-practices.md` | Pandas DataFrame/Series operations, performance optimization, memory management, integration with Streamlit and Plotly | pandas, DataFrame, vectorization, SettingWithCopyWarning, memory optimization, dtypes, groupby, merge, performance, method chaining | `rules/200-python-core.md` |
|| `300-bash-scripting-core.md` | Foundation bash scripting patterns and essential practices | Bash, shell scripting, set -euo pipefail, error handling, strict mode, functions, variables, script structure, trap, exit codes, shellcheck, input validation | `rules/000-global-core.md` |
|| `300a-bash-security.md` | Shell script security, input validation, access control | Bash, security, input validation, command injection, path security, secure shell scripts, sanitization, permissions, privilege escalation, secrets management | `rules/300-bash-scripting-core.md` |
|| `300b-bash-testing-tooling.md` | Bash testing, debugging, development workflows, CI/CD | Bash, testing, ShellCheck, bats, shell script testing, CI/CD, debugging, static analysis, linting, test automation | `rules/300-bash-scripting-core.md` |
|| `310-zsh-scripting-core.md` | Foundation zsh scripting patterns and essential practices | Zsh, Z shell, zsh features, arrays, functions, oh-my-zsh, emulate, setopt, parameter expansion, globbing | `rules/300-bash-scripting-core.md` |
|| `310a-zsh-advanced-features.md` | Advanced zsh features, performance optimization, complex scripting patterns | Zsh, completion system, modules, hooks, advanced features, performance optimization, compinit, zstyle, autoload, scripting | `rules/310-zsh-scripting-core.md` |
|| `310b-zsh-compatibility.md` | Cross-shell compatibility, migration strategies, mixed environments | Zsh, shell compatibility, bash vs zsh, portable scripts, cross-shell, migration, emulate, POSIX compliance, scripting, shell scripting | `rules/300-bash-scripting-core.md` |
|| `350-docker-best-practices.md` | Dockerfiles, multi-stage builds, image security, supply-chain integrity, runtime hardening, Docker Compose usage, CI/CD integration. Applies to polyglot projects with emphasis on Python. | Docker, Dockerfile, containers, multi-stage builds, layer caching, image optimization, docker-compose, BuildKit, distroless, security scanning, SBOM, non-root, healthcheck | `rules/202-markup-config-validation.md` |
|| `420-javascript-core.md` | Applies to all pure JavaScript projects, Node.js scripts, and backend logic. Covers syntax, asynchronous patterns, testing, and project configuration. | JavaScript, ES2024, ESM, Node.js, JSDoc, Biome, node:test, Immutability, Async/Await, Functional Programming | `rules/000-global-core.md` |
|| `430-typescript-core.md` | Applies to all TypeScript files in frontend and backend environments. Covers type definitions, generics, validation schemas, and compiler configuration. | TypeScript, Zod, Strict Mode, Type Inference, Union Types, Satisfies, Generics, Utility Types, Matt Pocock, Total TypeScript | `rules/000-global-core.md` |
|| `440-react-core.md` | Applies to all React-based projects, including Next.js applications, Vite Single Page Apps (SPAs), and component libraries. Covers folder structure, state management, data fetching, styling, and testing. | React, Next.js, RSC, Hooks, Tailwind, Zustand, TanStack Query, Shadcn, Feature-based, TypeScript, Vitest, Testing Library, debug hooks, fix React error, component rendering | `rules/000-global-core.md`, `rules/420-javascript-core.md`, `rules/430-typescript-core.md` |
|| `441-react-backend.md` | Applies to all React applications requiring backend API integration. Covers framework selection, API patterns, authentication, and development workflows for full-stack applications. | React backend, FastAPI, Flask, Python API, CORS, JWT, authentication, API integration, full-stack, Express alternative, fetch, axios, TanStack Query backend, Next.js API routes, httpOnly cookies | `rules/440-react-core.md`, `rules/200-python-core.md` |
|| `500-frontend-htmx-core.md` | Frontend developers using HTMX in web applications (framework-agnostic, applies to all backends) | htmx attributes, client-side, events, css transitions, debugging, browser compatibility, hx-get, hx-post, hx-swap, hx-trigger, hx-target | — |
|| `600-golang-core.md` | Foundational Go development practices with modern tooling (Go 1.21+), project structure, error handling, testing, and concurrency fundamentals | Go, Golang, go.mod, modules, error handling, interfaces, goroutines, channels, testing, go fmt, golangci-lint, concurrency, context, defer | `rules/000-global-core.md` |
|| `800-project-changelog.md` | High-signal, audit-friendly changelog maintenance using Conventional Commits | CHANGELOG, changelog format, semantic versioning, release notes, conventional commits, Unreleased section, scope patterns, project governance, git workflow, version control | `rules/000-global-core.md` |
|| `801-project-readme.md` | Project documentation, technical writing, developer experience | README, project documentation, getting started, setup instructions, badges, Quick Start, Contributing, License, project structure, technical writing | `rules/000-global-core.md` |
|| `802-project-contributing.md` | Professional contribution workflows for commits, pull requests, and rule authoring standards | CONTRIBUTING, pull requests, code review, contribution guidelines, branching strategy, Conventional Commits, rule authoring, PR templates, project governance, git workflow | `rules/000-global-core.md` |
|| `803-project-git-workflow.md` | Git workflow management including branching strategies, pull requests, protected branches, and pre-merge validation for GitHub | git, workflow, branching strategy, GitHub, pull requests, feature branches, protected branches, git validation, branch naming, PR workflow, Conventional Commits | `rules/800-project-changelog.md`, `rules/802-project-contributing.md` |
|| `820-taskfile-automation.md` | Project automation using Taskfile.yml for consistent development workflows | Taskfile, task automation, Taskfile.yml, build automation, task runner, Task, portable tasks, error handling, categorized help, user experience, task discovery | `rules/202-markup-config-validation.md` |
|| `900-demo-creation.md` | Realistic, deterministic, and effective demo application creation with narrative clarity | Demo creation, synthetic data, realistic demos, data generation, demo applications, narrative design, reproducible data, progressive disclosure, Streamlit, data visualization | — |
|| `901-data-generation-modeling.md` | All data generation (Python generators), SQL schema design (DDL), view creation, and analytics queries for utility demo project. Applies to grid data, customer data, and all future data domains. | Data modeling, naming conventions, Kimball, dimensional modeling, fact tables, dimension tables, foreign keys, view taxonomy, Business Analyst, data generation, backward compatibility, entity IDs, temporal columns, surrogate keys, SCD Type 2 | `rules/000-global-core.md`, `rules/100-snowflake-core.md`, `rules/102-snowflake-sql-demo-engineering.md`, `rules/930-data-governance-quality.md`, `rules/940-business-analytics.md` |
|| `920-data-science-analytics.md` | Data science and analytics on Snowflake with ML lifecycle, visualization best practices, performance optimization, and Snowflake-native tooling integration | Data science, Snowflake, pandas, Snowpark, ML, model lifecycle, feature engineering, NaN handling, model versioning, Jupyter | `rules/200-python-core.md` |
|| `930-data-governance-quality.md` | Data quality, governance, and operational reliability throughout the data lifecycle | Data governance, data quality, lineage, metadata management, compliance, data catalog, Great Expectations, schema evolution, data observability, incident response | — |
|| `940-business-analytics.md` | Business-oriented queries, reports, visualizations, and dashboards for business audience consumption across executive, director, analyst, and operational roles | Business intelligence, dashboards, KPIs, reporting, visualization, stakeholder reports, metrics, Snowsight, executive dashboards, data storytelling, WCAG accessibility | — |

---

## Common Rule Dependency Chains

This section visualizes common rule loading patterns to help AI assistants calculate token costs and load rules in the correct order.

**Reading the Trees:**
- Indentation shows dependency relationships
- Token budgets shown in parentheses
- "Minimal/Standard/Complete" shows progressive loading strategies
- Always load parent rules before child rules

### Streamlit Dashboard Development
```
000-global-core (1300 tokens)
└── 100-snowflake-core (1800 tokens)
    └── 101-snowflake-streamlit-core (3700 tokens)
        ├── 101a-snowflake-streamlit-visualization (3600 tokens)
        ├── 101b-snowflake-streamlit-performance (3800 tokens)
        └── 101c-snowflake-streamlit-security (2550 tokens)

Token Cost Scenarios:
• Minimal (basic app):        000 + 100 + 101      = ~6,800 tokens
• Standard (with viz):         + 101a               = ~10,400 tokens
• Performance (caching):       + 101b               = ~14,200 tokens
• Complete (production-ready): + 101c               = ~16,750 tokens
```

### Cortex Agent Development
```
000-global-core (1300 tokens)
├── 100-snowflake-core (1800 tokens)
│   ├── 106-snowflake-semantic-views-core (2800 tokens)
│   │   ├── 106a-snowflake-semantic-views-advanced (2200 tokens)
│   │   └── 106b-snowflake-semantic-views-querying (5000 tokens)
│   └── 111-snowflake-observability-core (2000 tokens)
│       ├── 111a-snowflake-observability-logging (varies)
│       └── 111c-snowflake-observability-monitoring (varies)
└── 115-snowflake-cortex-agents-core (2200 tokens)
    ├── 115a-snowflake-cortex-agents-instructions (800 tokens)
    └── 115b-snowflake-cortex-agents-operations (2400 tokens)

Token Cost Scenarios:
• Minimal (agent setup):         000 + 100 + 115           = ~5,300 tokens
• Standard (with semantic views): + 106                     = ~8,100 tokens
• Advanced (instructions):        + 115a                    = ~8,900 tokens
• Production (operations):        + 115b + 111             = ~13,300 tokens
• Complete (all capabilities):    + 106a + 106b            = ~20,500 tokens
```

### Cortex Analyst Integration
```
000-global-core (1300 tokens)
└── 100-snowflake-core (1800 tokens)
    └── 106-snowflake-semantic-views-core (2800 tokens)
        ├── 106a-snowflake-semantic-views-advanced (2200 tokens)
        ├── 106b-snowflake-semantic-views-querying (5000 tokens)
        └── 106c-snowflake-semantic-views-integration (4600 tokens)

Token Cost Scenarios:
• Minimal (basic analyst):    000 + 100 + 106       = ~5,900 tokens
• Standard (with queries):    + 106b                 = ~10,900 tokens
• With integration:           + 106c                 = ~15,500 tokens
• Complete (full capability): + 106a                 = ~17,700 tokens
```

### Performance Tuning Workflow
```
000-global-core (1300 tokens)
└── 100-snowflake-core (1800 tokens)
    ├── 103-snowflake-performance-tuning (800 tokens)
    ├── 105-snowflake-cost-governance (1150 tokens)
    └── 119-snowflake-warehouse-management (3650 tokens)

Token Cost Scenarios:
• Minimal (query optimization):  000 + 100 + 103      = ~3,900 tokens
• Standard (with warehouses):    + 119                 = ~7,550 tokens
• Complete (cost governance):    + 105                 = ~8,700 tokens
```

### Data Pipeline Development
```
000-global-core (1300 tokens)
└── 100-snowflake-core (1800 tokens)
    ├── 104-snowflake-streams-tasks (850 tokens)
    │   └── 122-snowflake-dynamic-tables (5200 tokens)
    ├── 108-snowflake-data-loading (950 tokens)
    └── 124-snowflake-data-quality-core (6200 tokens)

Token Cost Scenarios:
• Minimal (basic CDC):           000 + 100 + 104     = ~3,950 tokens
• With dynamic tables:           + 122                = ~9,150 tokens
• With data loading:             + 108                = ~10,100 tokens
• Complete (with quality):       + 124                = ~16,300 tokens
```

### Cortex Search Implementation
```
000-global-core (1300 tokens)
└── 100-snowflake-core (1800 tokens)
    ├── 116-snowflake-cortex-search (4000 tokens)
    ├── 108-snowflake-data-loading (950 tokens)
    └── 115-snowflake-cortex-agents-core (2200 tokens)
        └── 115b-snowflake-cortex-agents-operations (2400 tokens)

Token Cost Scenarios:
• Minimal (search setup):        000 + 100 + 116     = ~7,100 tokens
• With document loading:         + 108                = ~8,050 tokens
• Agent integration:             + 115                = ~10,250 tokens
• Complete (operations):         + 115b               = ~12,650 tokens
```

### SPCS Container Deployment
```
000-global-core (1300 tokens)
└── 100-snowflake-core (1800 tokens)
    ├── 120-snowflake-spcs (3550 tokens)
    ├── 119-snowflake-warehouse-management (3650 tokens)
    └── 111-snowflake-observability-core (2000 tokens)
        ├── 111a-snowflake-observability-logging (varies)
        └── 111c-snowflake-observability-monitoring (varies)

Token Cost Scenarios:
• Minimal (basic SPCS):          000 + 100 + 120     = ~6,650 tokens
• With compute pools:            + 119                = ~10,300 tokens
• Complete (observability):      + 111                = ~12,300 tokens
```

**Usage Tips:**
- Load only what you need based on task complexity
- "Minimal" scenarios cover 70-80% of typical use cases
- "Standard" adds commonly needed extensions
- "Complete" for production-ready, comprehensive implementations
- If unsure, start with Minimal and load additional rules as needed
